\chapter{Реализация алгоритмов и программная система}\label{part:three}

Глава \ref{part:three} посвящена вопросам реализации \app{структур данных}, стратегий, алгоритмов и программных средств разработки системы автоматического доказательства первопорядковых теорем в ислислениях позитивно--образованных формул. В качестве исходной информации для реализации выступают результаты, полученные в предыдущей главе диссертации. Реализация включает средства анализа количественных и структурных характеристик процесса поиска ЛВ, а также средств управления им. В результате реализации создана программная система АДТ и среда поддержки разработки систем АДТ, ориентированные как на задачи, возникающие при решении практических приложений, так на задачи, традиционно, считающиеся математическими (абстрактные).

%-------------------------------------------------------------------
%---------------------------------АРХИТЕКТУРА-----------------------
%-------------------------------------------------------------------
\section{Архитектура системы}
На рис.~\ref{pic:design1} изображена архитектура программной системы. В основе подхода к проектированию архитектуры системы использовалась .... методика проектирования. Архитектура представляет собой ....

\begin{figure}[h]
	%\vspace{0.5cm}
	\centering
	\includegraphics[width=0.7\linewidth]{pics/Design1.eps}
	\caption{Архитектура системы}
	\label{fig:design1}
\end{figure}

Программная система АДТ состоит из следующих функциональных блоков (подсистем):
\begin{description}
  \item{Супервизор} --- подсистема исполнения любой реализованной стратегии. Поскольку особенности некоторых стратегий требуют анализа и модификации данных на всех уровнях вывода, то необходима подсистема, которая следит за всеми процессами ЛВ, и посылает по запросу нужную инфомрацию о ЛВ. Данная подсистема реализована как отдельный поток исполнения, ожидающий сигналов.
  \item{Контроллер доступа к ПО--формуле} --- подсистема эффективного доступа к частям ПО--формулы.
  \item{Выборщик стратегий} --- подсистема
  \item{Поиск ответных подстановок} --- подсистема
  \item{Транслятор}
  \item{Интерфейсы} --- подсистема интерфейсов к системе. Пользовательские и прикладные.

\end{description}

При помощи такой архитектуры реализуется.... разнообразие алгоритмов и стратегий. .

Разработанная система может не только устанавливать тот факт что формула является теоремой, но и распознавать некоторые противоречия. В частности, если хотя бы одна из ветвей ДСВ не может больше изменяться не по причинам ограничения ресурсов, это значит что больше не существует допустимых вопросов и ответов на них, т.е. ветвь принципиально неопровержима.


%=================================реализация====================================
\section{Программная реализация системы АДТ}

Программная система АДТ реализована в среде программирования D. Язык D и его система программирования обладают рядом особенностей, позволяющих повысить продуктивность и упростить реализацию алгоритмов системы. Компилятор языка D генерирует машинный код по качеству сопоставимый с компиляторами языков C/C++, причем компилирование осуществляется в машинный код вычислительной системы, способный выполняться непосредственно микропроцессором без использования какой--либо виртуальной машины. Язык D обладает множеством полезных синтаксических элементов и возможностей, присущих языкам, построенным с использованием виртуальной машины. Так, D содержит в себе встроенные средства поддержки ассоциативных массивов. Ассоциативные массивы применяются для эффективной реализации некоторых структур данных, образующих основные классы системы АДТ. Они задают соответствие между символом (в терме) и адресом структуры в динамической оперативной памяти. Также D непосредственно поддерживает указатели (references), что позволяет эффективно получать доступ к некоторым структурами данных, обладающих ссылочной семантикой. Следует отметить, что стандартный комплект поставки D включает в себя мощную стандартную библиотеку, в которой есть средства для обработки строк. Среди стандартных средств программирования среды D необходимо выделить библиотеку поддержки параллельных вычислений, которая основана на принципах, заложенных в признанном лидере по параллельным вычислениям --- языке Erlang. Кроме того, одним из полезных свойств языка D является поддержка встроенного управления динамической оперативной памятью и сборщика мусора. Причем как процедурами выделения памяти, так и сборкой мусора можно управлять внешними библиотеками, т.е. настраивать управление оперативной памятью в системе АДТ. Эти возможности позволяют в рамках разработки системы АДТ настраивать (fine tuning) процедуры обработки динамических структур данных на определенные задачи. Таким образом, среда программирования D представляет собой баланс между системным и прикладным уровнем программирования.


%-----------------------------------------
\subsection{Менеджер памяти}

Как было сказано выше, одна из методик экономии памяти --- это проектирование компактных структур данных. Под компактностью, в частности, понимается оптимизированное использование оперативной памяти. Выделение (allocation) оперативной памяти для структур (records) фиксированного размера реализовано на основе стандартного подхода \cite{}, основанного на использовании больших массивов однородных структур. Массив структур отводится при помощи менеджера памяти операционной системы, и, затем, преобразуется в однонаправленный список свободных структур. Новые структуры выделяются из этого однонаправленного списка. При освобождении структура возвращается обратно в этот список для повторного использования. При исчерпании структур в списке и наличии свободной оперативной памяти выделяются новые массивы.

В системе АДТ для каждой разновидности структур (records) выделяется собственный массив, а также ведется собственный однонаправленный список свободных структур. Сборка мусора синхронизирована со сборщиком мусора используемой системы программирования D.

%---------------------------------------------
\subsection{Алгоритмы анализа и преобразования выражений в ходе поиска АДТ}

\paragraph{Копирование подформул.}
В системе реализовано два типа копирования подформул \emph{мягкий} (soft copy) и \emph{жесткий} (hard copy). Жесткий тип копирования предназначен для корректного копирования консеквентов и перемещения их к базе. Такое перемещение должно разорвать связь между переменными и связанными с ними термами, для того что бы освободить переменную для дальнейшего использования в других шагах вывода, но при этом, что бы в базу попали именно те термы, до которых данная переменная конкретизирована. Кроме того, такой тип копирования нужен для параллельных стратегий, что бы переместить формулу в полностью независимый процесс.

Второй тип копирования, мягкий, предназначен для корректной обработки НЭЭ с учетом бэктрэкингда. Поскольку при откатах поиска необходимо восстанавливать информацию о том какой НЭЭ был связан с каким термом. Копирование НЭЭ осуществляется копированием его ссылки с сохранением его конкретизации. Потом такой НЭЭ в базе идентифицируется как конкретизированный и работа ведется с привязанным термом.

Копирование подформул в процессе шага вывода, требует, во--первых, разыменования всех экзистенциальных переменных, и всех неконкретизированных универсальных переменных. Поскольку структура копируемых подформул является древовидной, то для копирования применяется рекурсивный алгоритм, начинающий свою работу с корня дерева. Опишем подробно схему алгоритма копирования.

В начале работы алгоритма задан пустой словарь переменных, которые необходимо разыменовывать и соответствующих им разыменованных переменных. В скопированном узле (типового квантора) для его кванторных переменных создаётся новый список переменных той же длины что и исходный и того же типа (EVARIABLE или AVARIABLE), данный список есть копия исходного списка переменных, а в словарь заносятся соответствия между исходными переменными и новыми. Далее копирование конъюнкта требует создание нового конъюнкта такой же длины что и исходный, в который последовательно заносятся копии содержащихся в нём термов. Копирование термов производится рекурсивно. Создаётся новый корневой узел, в котором символ определяется следующим образом:  если исходный символ это неконкретизированная переменная (либо EVARIABLE), и она уже входит в словарь, то её копией будет соответствующее ей значение в словаре. Это делается для того что бы одинаково разыменовать одинаковые переменные. Если переменная конкретизирована, то копируется значение функции {\tt getValue()}. Отметим, что не может быть ситуации, когда встречается неконкретизированная переменная, которой нет в словаре, поскольку используются только замкнутые формулы, а в словарь последовательно добавляются все переменные управляемые кванторами; если исходный символ имеет тип CONSTANT, FUNCTION, ATOM или EVARIABLE, не содержащаяся в словаре, то новый символ есть ссылка на исходный. Далее для терма копируются все его аргументы. После того как копирование конъюнкта завершено, копируется системная информация о ТК. Далее процедуре копирования дочерних узлов передаётся текущий словарь, который реализован с помощью чанков, для того что бы более глубокие, чем исходный, узлы могли разделять информацию о словаре переменных.
%этап использования алг. (В каком контексте используется.)

%--------------
\paragraph{Мэтчинг с НЭЭ. Черновик} В системе реализован вариант классического алгоритма мэтчинга (matching), адаптированный для случая содержания в термах НЭЭ. Пусть дано два терма $q$ и $b$, соответствено из базы и конъюнкта вопроса. Отметим, что поскольку $b$ --- это терм из базы, то он не содержит универсальных переменных. Задается пустая подстановка $a$ (которая будет дополняться позже).
\begin{enumerate}
\item Если $q$ --- это константа. Тогда, если $b$ тоже константа, проверить их корневые символы, если совпадают, то вернуть $a$, иначе вернуть NULL. Если $b$ --- это НЭЭ, то применить подстановку $\{b \rightarrow q\}$ и добавить её к $a$, возвратить $a$. Во всех остальных случаях возвратить NULL.

\item Если $q$ --- это экзистенциальная переменная. Если $b==q$, то возвратить $a$. Если $b$ --- это НЭЭ, то применить подстановку $\{b \rightarrow q\}$ и добавить её к $a$, возвратить $a$. Во всех остальных случаях возвратить NULL.

\item Если $q$ --- это универсальная переменная, то применить подстановку $\{q \rightarrow b\}$ и добавить её к $a$, возвратить $a$.

\item Если $q$ --- это НЭЭ. Если $b$ тоже НЭЭ, то если $b==q$ вернуть $a$, иначе вывод разветвить на две части, в первом случае алгоритм возвращает NULL, во втором случае применить подстановку $\{q \rightarrow b\}$ и добавить её к $a$, возвратить $a$. Если $b$ --- тегирован как FUNCTION, то, если $q$ является подтермом $b$ возвратить NULL. Во всех остальных случаях применить подстановку $\{q \rightarrow b\}$ и добавить её к $a$, возвратить $a$.

\item Если $q$ тегирован как FUNCTION. Если $b$ тоже тегирован как FUNCTION, то если корневые символы $q$ и $b$ не совпадают, то возвратить NULL. Если совпадают, то это одноименные функции, одинаковой арности. Последовательно применить алгоритм матчинга для всех попарно соответствующих термов. Если применение алгоритма возвращает не NULL, то результат применить (как подстановку) и добавить к $a$. Если получен NULL, то отменить $a$ и вернуть NULL. Если $b$ --- это НЭЭ, то применить подстановку $\{b \rightarrow q_s(h_1,...,h_n)\}$ и применить алгоритм мэтчинга ко всем парам $(h_i, q_i)$, где $q_s$ --- это корневой символ $s$, $n$ --- арность $q$, $h_i$ --- новые НЭЭ, $i = \bar{1,n}$. Полученные результаты применить и добавить к  $a$, возвратить $a$.
\end{enumerate}

%---------------
\paragraph{Композиция подстановок}
Хранилище подстановок содержит подстановки для отдельных атомов конъюнкта вопроса. Для того, чтобы получить ответ на вопрос, необходимо произвести композицию подстановок, соответствующих всем атомам конъюнкта вопроса. Хотя и существуют известные классические алгоритмы композиции подстановок, опишем такой, который учитывает НЭЭ и особенности реализации структуры обобщенного терма, а именно использование аргумента как места для подстановки.

Пусть дан список подстановок $QList$, дана пустая подстановка $Answer$, называемая результирующей. Алгоритм последовательно просматривает все подстановки $q \in QList$, и производится композиция $Answer$ и $q$. В случае удачи, алгоритм переходит к следующему элементу $QList$, иначе алгоритм возвращает NULL, т.е. заканчивается неудачей.

Теперь опишем алгоритм композиции $Answer$ и $q$. Связью (binding) будем называть часть подстановки вида $\{x \rightarrow t\}$, т.е. одинарная подстановка для одной универсальной переменной или НЭЭ. Соответственно, подстановка есть список связей. %Упомянуть во второй главе.

Для каждой связи $b_i \in q$ произвести композицию $b_i$ и $Answer$, в случае неудачи какого--либо шага, возвращается NULL.

Теперь опишем алгоритм композицию связи $b$ и подстановки $Answer$. Для каждого элемента $a \in Answer$ проводим композицию $b$ и $a$. В случае удачи, проводим композицию результата и $Answer$, берём следующий элемент $Answer$.

%Что такое ``Применить'' связь. Подстановка. Определить во второй главе.
Рассмотрим вариант композиции двух связей $b$ и $a$. Применить связь $b$. Если связь $a$ стала рекурсивной, т.е. правая часть содержит левую, то алгоритм заканчивается неудачей, связь $b$  сбрасывается. Иначе, если левые части $b$ и $a$ различаются, то возвратить результат объединения $b$ и $a$. Иначе, если левые части совпадают, то, если хотя бы одна из подстановок уже применена, то если правые части совпадают алгоритм возвращает любую из подстановок, иначе алгоритм терпит недуачу; если обе подстановки не применены, то выполняем алгоритм унификации правых частей. Если он закончился успехом, то возвратить подстановку и унификацию, иначе возвратить NULL.


%-------------------------
\paragraph{Шаг вывода.} Когда выбран вопрос и ответ на него, производится трансформация формулы, согласно определению \ref{omega}.
Данная трансформация состоит из следующих шагов:
\begin{enumerate}
\item Применить ответную-подстановку (\texttt{answer.apply()}).
\item Произвести копирование подформул-консеквентов заданого вопроса, с применением мягкого и жесткого копирования. Для каждого консеквента создаётся отдельный узел ДСВ.
\item Сбросить ответную-подстановку.
\item Линковка полученных копий-подформул с имеющейся базовой подфомрулой. То есть, линковка полученных узлов ДСВ, с соответствующим листом ДСВ.
\item Возврат результатов полученных в ходе данной операции.
\end{enumerate}


%------
\paragraph{Выбор вопроса для осуществления шага вывода} % Потенциально 2 главы материал
Алгоритм выбора вопроса базируется на нескольких стратегиях. Первая стратегия, стратегия по умолчанию, задает вопросам приоритет в соответствии со следующим правилом. Сначала просматривается список целевых вопросов. Затем, если для них не получен ответ, то просматриваются простые вопросы, не являющиеся глубокими и не содержащие дизъюнктивное ветвление. Далее просматриваются глубокие вопросы, затем все остальные, в т.ч. с дизъюнктивным ветвлением.

Вторая стратегия реализует выбор вопроса по критерию. Критерий выбора --- это некоторая количественная или структурная характеристика вопроса (подформулы). Примерами критериев выступают размер конъюнкта, наличие определенных термов в конъюнкте, частота удачного использования вопроса в ЛВ (рейтинг вопроса). Вопросам сопоставляется значение заданного критерия как приоритет использования вопроса. Вопросы, которым не присвоены значения критериев считаются низкоприоритетнымии. % Описать алгоритм выбора вопроса при заданных приоритетах.

Третья стратегия --- это ручной выбор очередного вопроса пользователем.

\paragraph{Предобработка структуры формул}
Предобработка структуры ПО--формул используется для упрощения формулы, которое, вероятного, влечет уменьшение сложности поиска ЛВ. Упрощение формулы достигается удалением очевидно ненужных фиктивных кванторов, слиянием нескольких вопросов в один, уменьшение глубины формулы и т.п. При этом происходит уменьшение сложности, в основном, сокращается длина вывода и пространство поиска переборных алгоритмов.

%\paragraph{Проверка доказательства} Имеется протокол вывода. Проверяется его корректность.

%====================================================================
%======================== СИСТЕМНЫЕ ПРЕДИКАТЫ =======================
%====================================================================
\subsection{Системные предикаты и вычислимые термы}
В логических языках программирования, например, Прологе \cite{Bratko}, введены так называемые системные предикаты (встроенные предикаты, built-in predicates), особенность которых заключается в том, что они или выполняют некоторое побочное действие, например, вывод на экран, чтение файла и др., или их истинность вычисляется из значений параметров, например, \texttt{var(X)} в Прологе определяет, является ли терм \texttt{X} переменной. В данной разделе рассматривается использование системных предикатов для управления логическим выводом в процессе построения автоматического доказательства теорем в исчислении ПО--формул, то есть как способ задания дополнительных знаний о задаче в виде модификаторов стратегии, используемой по умолчанию.

Будем называть системным предикатом такой предикат, атомы которого входят в конъюнкты дерева ПО--формулы, но не участвуют непосредственно в ЛВ. Системные предикаты не имеют прямого отношения к формализации задачи, однако влияют на процесс ЛВ некоторыми побочными действиям, их истинностные значения вычисляются, выводят некоторую системную информацию. В языках логического программирования, например, Прологе, системные предикаты служат, в основном, для исполнения некоторых интерактивных действий: вывод информации на экран, чтение и запись файла, добавление и удаление фактов и др.

Введем следующие системные предикаты:
\begin{description}

\item{\texttt{Next(L)}} --- переход к вопросу, помеченному идентификатором \texttt{L}. Предикат помещается в конъюнкт корневой вершины консеквента вопроса.  Если на данный вопрос будет произведен ответ, то следующим вопросом, для которого будет производится выбор ответа, будет вопрос (множество вопросов), помеченный идентификатором \texttt{L}. Таким образом, при помощи данного предиката задаются варианты порядка ответа на вопрос.

\item{\texttt{OffQuestion(L)/OnQuestion(L)}} --- отключение/включение вопроса с идентификатором \texttt{L}. Отключенный вопрос объявляется неактивным, то есть не принимает участие в логическом выводе, при этом в любой момент может быть заново включен.

\item{\texttt{RemQuestion(L)}} --- удаление вопроса с идентификатором \texttt{L}.

\item{\texttt{RemFact(L)} и \texttt{RemPatternFact(L)}}. Удаление факта помеченного идентификатором \texttt{L}, а также удаление всех основных примеров \texttt{L}, в случае если \texttt{L} --– терм.

\item{\texttt{OffFact(L)/OnFact(L)}} --- отключение и включение факта с именем \texttt{L}. Поведение подобно включению и отключению вопросов.

\item{\texttt{Write(T)}} --- печать терма \texttt{T}.

\item{\texttt{Save(L)}} --- пометить состояние процесса поиска ЛВ в данной базовой подформуле идентификатором \texttt{L}.

\item{\texttt{Rollback(L)}} --- откатить (backtrack) состояние вывода в базовой подформуле до состояния \texttt{L} с утерей более поздних по отношению к \texttt{L} маркировок.

\item{\texttt{Commit(L)}} --- фиксировать состояние базы \texttt{L} как неоткатываемое, при этом фиксируются все состояния, помеченные ранее, чем \texttt{L} .
\end{description}
Предикаты \texttt{Commit} и \texttt{Rollback} без параметров фиксируют или откатывают последнюю метку. Для пометки выражений используется следующий синтаксис \texttt{E'(L)}, где \texttt{E} --– выражение, \texttt{L} --– метка. Кроме того, вводятся арифметические операции, используемые в конъюнкте вопроса и вычисляющие свои аргументы. Если арифметическая операция выполняется над полученными в подстановке аргументами, то подстановка используется в шаге вывода, иначе данная подстановка отвергается.

Рассмотрим некоторые ситуации, при которых перечисленные выше предикаты можно использовать и получать новые свойства процесса поиска ЛВ.

\paragraph{Ключевые точки в доказательстве} Нередко бывает так, что заранее известна некоторая точка, через которую должно пройти доказательство. Достаточно простым примером может служить задача поиска пути в городе между двумя точками, находящимися на разных берегах реки, при наличии одного моста. Понятно, что любой путь будет проходить через мост, однако заранее неизвестно как именно строится этот путь. Предположим, что первая группа вопросов отвечает за правила движения в первой половине города, а вторая за движение во второй половине. Очевидно, что нет смысла пытаться отвечать на вопросы второй группы, пока не преодолен мост, а после его преодоления нет смысла отвечать на вопросы первой группы. Таким образом, перед началом доказательства, вопросы второй группы объявляются неактивными, а после ответа на специальный вопрос описывающий факт перехода через мост, неактивными объявляются вопросы первой группы, а вопросы второй группы включаются.

\paragraph{Очищение формулы} Другим типом задач являются задачи с некоторой дискретизацией шагов. Например, если моделируется переход системы из одного состояния в другое во времени, шаг такого перехода может быть эквивалентен нескольким шагам правила вывода . Часть выведенной информации, отвечающая за сам процесс перехода, может быть удалена, а другая часть, отвечающая за описание нового состояния, сохраняется. Примером может служить задача планирования движения робота в дискретном пространстве. Часть информации устаревает, и ее необходимо регулярно удалять из базы. Кроме того, устаревать могут и вопросы, отвечающие за конструктивные средства описания перехода из одного состояния в другое (движение ноги, кабины лифта и др.). Например, в базе должна оставаться история пройденного пути или решения поставленных роботу задач (обслужить все вызовы и т.п.).

\paragraph{Улучшение эффективности вывода} Рассмотрим простую задачу вычисления n-го элемента ряда Фибоначчи. На языке ПО--формул данная задача вычисления 10-го элемента ряда формализуется следующим образом:
\begin{equation}
	\forall\colon\boldsymbol{True} - \exists\colon f(1,1), f(2,2) -
	\left\lbrace
	\begin{array}{l}
		\forall n,x,y\colon f(n,x),f(n+1,y) - \exists\colon f(n+2,x+y) \\
		\forall x\colon f(10,x) - \exists\colon \boldsymbol{False},
	\end{array}\right.
\end{equation}
где в процессе поиска подстановки $\theta$ операция «+» из значений ее аргументов вычисляется в константу (целое число), данная константа используется в $\theta$ вместо операции «+»; в консеквенте вопроса операция «+» заменяется на вычисленную константу во время применения подстановки.

В ходе ЛВ, база постепенно наполнится фактами и станет возможным ответ на целевой вопрос. При обычном выводе, с каждым ответом на первый вопрос в базу помещаются ответы, некоторые из которых будут дублироваться и как следствие могут производиться излишние вычисления. Вычисления ряда Фибоначчи подразумевает, что для вычисления последующего элемента достаточно использовать лишь два предыдущих элемента ряда. Это значит, что базу можно ограничить двумя последними добавленными элементами. Поскольку ответ на первый вопрос приводит к добавлению базы только одного нового факта, базу можно ограничить с помощью ввода системного предиката, удаляющего один самый старый элемент базы. Первый вопрос ПО--формулы с системным предикатом будет выглядеть так:
\begin{equation}
	\forall n,x,y\colon f(n,x),f(n+1,y) - \exists\colon f(n+2,x+y)'(n+2), remFact(n)
\end{equation}
при этом запись $'(L)$ означает «пометить терм меткой \texttt{L}». Соответственно база данной ПО--формулы выглядит так:
\begin{equation}
\exists\colon f(1,1)'1, f(2,2)'2
\end{equation}

Удаление элементов из базы можно организовать без использования меток атомов, если использовать RemPatternFact:
\begin{equation}
	\forall n,x,y\colon f(n,x),f(n+1,y) - \exists\colon f(n+2,x+y)'(n+2), remPatternFact(f(n,_))
\end{equation}

Символ подчеркивания интерпретируется как и в Прологе в качестве анонимной переменной. Из базы будут удалены все факты, являющиеся основными примерами  $f(n,_)$. Нетрудно заметить, что такой подход эквивалентен предыдущему, однако не требует дополнительных меток атомов.

\paragraph{Косвенное управление} Вывод (в смысле, ввод/вывод данных) некоторой системной информации косвенно можно отнести к управлению логическим выводом. Поскольку данная информация может интерпретироваться пользователем или возможно иной программой управления ЛВ, как некоторые входные данные для принятия решения. Среди выводимой информации отметим следующие: текущий шаг вывода, имя базы, имя вопроса, ответная подстановка, количество фактов в базе, количество опровергнутых баз, количество вопросов, количество потенциальных ответов, время ЛВ и печать некоторых термов.

\paragraph{Вычислимые термы} При решении прикладных задач может быть что заранее известна семантика формулы, область интерпретации и т.д. Отсюда некоторые сложные термы можно просто вычислять, а не выводить классическим образом, или как в случае с равенствами не использовать апарат переписывания термов или кодированых деревьев. Для этого каждому символу сигнатуры должна быть поставлена в соответствие некоторая функция.

Для обобщенного терма реализован метод \texttt{GTerm reduce()}, вычисляющий его значение. Вычисление допустимо, если всего его аргументы являются также вычислимыми термами, а все переменные и НЭЭ связаны. В соответствии со строковым представлением символа ему задаётся семантика в виде лямбда выражения языка программирования D.

%------всякие дополнительные плюшки
\subsection{Входной язык системы и его транслятор}
Для загрузки ПО--формул в оперативную память системы АДТ используется подсистема трансляции. Подсистема позволяет загружать текстовые файлы с представлением исходной ПО-формулы. Транслятор реализован непосредственно в среде программирования D без использования дополнительных библиотек и инструментов. БНФ--грамматика входного языка приведена в приложении \ref{appl:bnf}. Входной язык предназначен исключительно для загрузки формулы, предварительная подготовка формулы осуществляется внешними утилитами.

\subsection{Файл конфигурации стратегий}
Стратегии, критерии, ... задаются при помощи конфигурационного файла. Формат файла представляет собой список двоек вида \texttt{<key>=<value>}, где ключ \texttt{<key>} --- идентификатор стратегии, критерия и т.п., а \texttt{<value>} --- значение данного ключа. Данные ассоциации помещаются в супервизор и, далее, используются в процессе поиска логического вывода.

Кроме того в данном файле задаются следующие ограничения: максимальная глубина терма; максимальное количество вопросов; максимальная глубина вывода; максимальное количество базовых подформул; максимальный объём потребляемой памяти; ограничение по вермени.

\subsection{Трансляция из формул ИП в ПО-формулы}


\subsection{Транслятор из TPTP в ПО-формулы}
Для представления формул на языке предикатов первого порядка используется формат представления формул библиотеки TPTP.

КНФ

%====================================================================
\section{Интерпретация полученных результатов}
С каждым узлом ДСВ связывается некоторе событие (сообщение). В каждый момент времени по текущену состоянию ДСВ можно интерпретировать что же произошло, путём последовательного вывода сообщений начиная от корня и заканчивая листом, для каждой базы.


%=====================================================================
%-----------интерактивные возможности
\section{Интерактивные возможности}
Например, при решении задачи о лифтах надо как-то добавлять информацию о поступающих выводах извне.

Как-то надо совместить это с Миниязычком.

%========================= КОММЕНТАРИИ ====================
\section{Комментарии по предложенным стратегиям} % Перенести.......возможно.
Анализ методик показывает, что структура вывода --- ДСВ тем более эффективна и тем выше её КПД чем больше элементов может содержаться в чанках. Размер чанка зависит от соответствующих консеквентов формулы. В терминах языка ПО-формул, более предпочтительными являются формулы имеющие как можно более крупные конъюнкты, и формулы имеющие глубину. Анализ задач из библиотеки TPTP показал что такой-то класс задач при формализации в языке ПОФ обладает описанным свойством.

При классическом подходе поскольку должны быть опровергнуты все базы, не стоит пытаться опровергать их одновременно, разростая тем самым дерево, можно сэкономить память строя однобокое дерево и доказывая всегда одну ветвь, таким подходом можно увеличить глубину пространства поиска.


%-----------------------------------------------------------------------------------------
%---------------------Интерфейс------------------------------------------------
%-----------------------------------------------------------------------------------------
\section{Интерфейс прикладного программирования}
Интерфейс прикладного программирования (API, Application programming interface) системы представляет собой набор классов с соответствующими методами.

Класс, представляющий \texttt{GTerm} включает следующие основные методы.
\begin{description}
  \item{string to\_string())} --- сгенерировать строковое представление терма;
  \item{bool contains(GTerm t)} --- определить, является ли один терм подтермом другого;
  \item{GTerm reduce()} --- вычислить значение обобщённого терма, если это возможно;
  \item{GTerm get\_hard\_copy()} --- жесткое копирование;
  \item{Answer matching(Gterm t)} --- мэтчинг;
  \item{Hash get\_hash()} --- вычислить хэш обобщенного терма;
\end{description}

Класс, представляющий \texttt{QData} включает следующие основные методы.
\begin{description}
  \item{Answer retrieve\_answer()} --- извлечь допустимый вопрос;
  \item{Stat get\_stat()} --- сбор статистики о вопросах;
\end{description}




%=================================================================
\section{Назначение системы АДТ}
Программная система является системой автоматического доказательства теорем в исчислении позитивно--образованных формул. Система относится к третьему классу систем АДТ, согласно классификации приведенной во введении.

Система предназначена для решения следующих классов задач. Во-первых, это любые задачи формализованные в первопорядковом языке ПО--формул. Во-вторых, это развёртывание теорий. В-третьих, решение задач, включающих в себя возможность изменения данных на лету (реального времени?). Четвёртое, это


%===============================================================================
\section{Количественные характеристики программной системы}
В 10-й версия программы состоит из следующих программных модулей:
\begin{enumerate}
\item[prisnif.d] --- Головная программа и анализ входных параметров командной строки (.. строк исходного кода);
\item[parser.d] --- Транслятор входного языка представления ПО--формул в структуры данных системы АДТ (.. строк исходного кода);
\item[gterm.d] --- Программа для работы с обобщенными термами (.. строк исходного кода);
\item[proofnode.d] --- Узел дерева состояний вывода (.. строк исходного кода);
\item[supervisor.d] --- Супервизор;
\item[question.d] --- Программа работы с подформулами-вопросами, которые как особая часть формулы, выделена в отдельную структуру. Вопрос в ключает в себя информацию типовом квантре соотвествующем вопросу и хранилище ответов для данного вопроса (350 строк исходного кода);
\item[pchunk.d] --- Чанк;
\item[qformulas.d] --- типовые кванторы;
\item[symbol.d] --- символ;
\item[answer.d] --- Программа работы с ответными подстановками, в ключающая в себя структуру связь \texttt{Binding} и собственно сам ответ \texttt{Answer} (200 строк исходного кода);
\item[misc.d] --- разное;
\item[g\_trans.pl] --- Подсистема трансляции формул с языка логики предикатов первого порядка и языка КНФ формата библиотеки TPTP, а также некоторая редукция и преобразования этих формул в ПО--представление (.. строк исходного кода).
\end{enumerate}
Всего реализовано .. строк кода.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "dis"
%%% End:
