\chapter{Программная система}


\section{Реализация}

Программная система является системой автоматического доказательства теорем в исчислении позитивно-образованных формул. Наша система относится ко второму классу систем АДТ, согласнно классификации приведенной во введении.

%-------------------------------------------------------------------
%---------------------------------АРХИТЕКТУРА-----------------------
%-------------------------------------------------------------------
\subsection{Архитектура системы}
Картинка.


%---------------------------------------------------------------------
%---------------------------СТРУКТУРЫ ДАННЫХ--------------------------
%---------------------------------------------------------------------
\subsection{Основополагающие структуры данных и управление памятью}
%этот кусок возможно надо перенести в предыдущую главу. или наоборот.

\textbf{Подстановка.} Подстановка есть список связей (binding) вида $X \rightarrow t$. В структуре Binding для $X$ и $t$ даны имена left и right соответственно. Определены следующие методы:

apply() --- применить подставноку. В каждой связи терм left связывается с термом right, т.е. аргумент left ссылается на right. 

reset() --- сброс подстановки. Аргумент left являющийся переменной приводится в состояние NULL, а left являющийся НЭЭ не сбрасиывается. Применяется непосредственно после шага вывода, для того что бы освободить переменные для дальнейшего использования, но при этом оставить НЭЭ связанными.

fullReset() --- сброс всей подстановки, включая НЭЭ. Применяется на этапе неудачной унификации, что бы вернуть все НЭЭ в прежнее состояни


\subsection{Вспомогательные алгоритмы}

\paragraph{Копирование подформул.}
В системе реализовано два тип копирования подформул. Первый тип предназначен для корректного копирования консеквентов и перемещения их к базе. Такое перемещение должно разорвать связь между переменными и связанными с ними термами, для того что бы освободить переменную для дальнешего использования в других шагах вывода, но при этом что бы в базу попали именно те термы с которыми данная переменная связана. Кроме того такой тип копирования нужен для параллельных стратегий, что бы переместить формулу в полностью независимый процесс. Данный тип копирования будем назвать жестким.

Второй тип копирования предназначен для правильной обработки НЭЭ с учетом бэктрэкингда. Поскольку при откатах необходимо востсанавливать информацию о том какой НЭЭ был связан с каким термом. Копирование НЭЭ проводится в прямую, вместе с привязанным к нему термом. Но потом такой НЭЭ в базе идентифицируется как связанный и работа ведется с привязанным термом. Такой тип копирования будем называть мягким.


\paragraph{Матчинг с НЭЭ.} В сисеме реализован классический алгоритм матчинга адаптированный для случая содержания в термах НЭЭ. Для матчихщася термов строятся уравнения. Поведение НЭЭ определяется следующим образом. Если в уравнении НЭЭ находится в првой части, то его поведение совпадает с поведением универсальной переменной. Если слева, то НЭЭ не может быть доопределён до другой переменной. Если и справа и слева находятся НЭЭ, то возникает два варианта развития. Либо они совпадают и оба доопределяются до общего НЭЭ, либо несовпадают и алгоритм матчинга заканчивается неудачей. 

\paragraph{Выбор вопроса.}

\paragraph{Трансформация формул.} Удаление фиктивынх кванторов. Расширение или углубление формулы.

\paragraph{Проверка доказательства.} Имеется протокол вывода. Проверяется его корректность.

%====================================================================
%======================== СИСТЕМНЫЕ ПРЕДИКАТЫ =======================
%====================================================================
\subsection{Системные предикаты и вычислимые термы}
В логических языках программирования, например, Прологе \cite{Bratko}, введены так называемые системные предикаты (встроенные предикаты, built-in predicates), особенность которых заключается в том, что они или выполняют некоторое побочное действие, например, вывод на экран, чтение файла и др., или их истинность вычисляется из значений параметров, например, var(X) в Прологе определяет, является ли терм X переменной. 
В данной работе рассматривается использование системных предикатов для управления логическим выводом в процессе построения автоматического доказательства теорем в исчислении ПО-формул, то есть как способ задания дополнительных знаний о задаче в виде модификаторов стратегии, используемой по умолчанию.

Будем называть системным предикатом такой предикат, атомы которого входят в конъюнкты дерева ПО-формулы, но не участвуют непосредственно в ЛВ. Системные предикаты не имеют прямого отношения к формализации задачи, однако влияют на процесс ЛВ некоторыми побочными действиям, их истинностные значения вычисляются, выводят некоторую системную информацию. В языках логического программирования, например, Прологе, системные предикаты служат, в основном, для исполнения некоторых интерактивных действий: вывод информации на экран, чтение и запись файла, добавление и удаление фактов и др. 
Введем следующие системные предикаты:
Next(L). Переход к вопросу, помеченному идентификатором L. Предикат помещается в коньюнкт корневой вершины консенквента вопроса.  Если на данный вопрос будет произведен ответ, то следующим вопросом, для которого будет производится выбор ответа, будет вопрос (множество вопросов), помеченный идентификатором L. Таким образом, при помощи данного предиката задаются варианты порядка ответа на вопрос.

OffQuestion(L)/OnQuestion(L). Отключение/включение вопроса с идентификатором L. Отключенный вопрос объявляется неактивным, то есть не принимает участие в логическом выводе, при этом в любой момент может быть заново включен.

RemQuestion(L). Удаление вопроса с идентификатором L. 

RemFact(L) и RemPatternFact(L). Удаление факта помеченного идентификатором L, а также удаление всех основных примеров L, в случае если L – терм. 

OffFact(L)/OnFact(L). Отключение и включение факта с именем L. Поведение подобно включению и отключению вопросов.

Write(T). Печать терма T.

Save(L). Пометить состояние процесса поиска ЛВ в данной базовой подформуле идентификатором L.

Rollback(L). Откатить (backtrack) состояние вывода в базовой подформуле до состояния L с утерей более поздних по отношению к L маркировок.

Commit(L). Фиксировать состояние базы L как неоткатываемое, при этом фиксируются все состояния, помеченные ранее, чем L. 

Предикаты Commit и Rollback без параметров фиксируют или откатывают последнюю метку.
Для пометки выражений используется следующий синтаксис E’(L), где E – выражение, L – метка.
Кроме того, вводятся арифметические операции, используемые в конъюнкте вопроса и вычисляющие свои аргументы. Если арифметическая операция выполняется над полученными в подстановке аргументами, то подстановка используется в шаге вывода, иначе данная подстановка отвергается.
Рассмотрим некоторые ситуации, при которых перечисленные выше предикаты можно использовать и получать новые свойства процесса поиска ЛВ.

\textbf{Ключевые точки в доказательстве.} Нередко бывает так, что заранее известна некоторая точка, через которую должно пройти доказательство. Достаточно простым примером может служить задача поиска пути в городе между двумя точками, находящимися на разных берегах реки, при наличии одного моста. Понятно, что любой путь будет проходить через мост, однако заранее неизвестно как именно строится этот путь. Предположим, что первая группа вопросов отвечает за правила движения в первой половине города, а вторая за движение во второй половине. Очевидно, что нет смысла пытаться отвечать на вопросы второй группы, пока не преодолен мост, а после его преодоления нет смысла отвечать на вопросы первой группы. Таким образом, перед началом доказательства, вопросы второй группы объявляются неактивными, а после ответа на специальный вопрос описывающий факт перехода через мост, неактивными объявляются вопросы первой группы, а вопросы второй группы включаются. 

\textbf{Очищение формулы.} Другим типом задач являются задачи с некоторой дискретизацией шагов. Например, если моделируется переход системы из одного состояния в другое во времени, шаг такого перехода может быть эквивалентен нескольким шагам правила вывода . Часть выведенной информации, отвечающая за сам процесс перехода, может быть удалена, а другая часть, отвечающая за описание нового состояния, сохраняется. Примером может служить задача планирования движения робота в дискретном пространстве. Часть информации устаревает, и ее необходимо регулярно удалять из базы. Кроме того, устаревать могут и вопросы, отвечающие за конструктивные средства описания перехода из одного состояния в другое (движение ноги, кабины лифта и др.). Например, в базе должна оставаться история пройденного пути или решения поставленных роботу задач (обслужить все вызовы и т.п.). 

\textbf{Улучшение эффективности вывода.} Рассмотрим простую задачу вычисления n-ого элемента ряда Фибоначчи. На языке ПО-формул данная задача вычисления 10-ого элемента ряда формализуется следующим образом:

\begin{equation}
	\forall\colon\boldsymbol{True} - \exists\colon f(1,1), f(2,2) - 
	\left\lbrace
	\begin{array}{l}
		\forall n,x,y\colon f(n,x),f(n+1,y) - \exists\colon f(n+2,x+y) \\
		\forall x\colon f(10,x) - \exists\colon \boldsymbol{False} 
	\end{array}\right.
\end{equation}

где в процессе поиска подстановки $\theta$ операция «+» из значений ее аргументов вычисляется в константу (целое число), данная константа используется в $\theta$ вместо операции «+»; в консеквенте вопроса операция «+» заменяется на вычисленную константу во время применения подстановки.

В ходе ЛВ, база постепенно наполнится фактами и станет возможным ответ на целевой вопрос. При обычном выводе, с каждым ответом на первый вопрос в базу помещаются ответы, некоторые из которых будут дублироваться и как следствие могут производиться излишние вычисления. Вычисления ряда Фибоначчи подразумевает, что для вычисления последующего элемента достаточно использовать лишь два предыдущих элемента ряда. Это значит, что базу можно ограничить двумя последними добавленными элементами. Поскольку ответ на первый вопрос приводит к добавлению базы только одного нового факта, базу можно ограничить с помощью ввода системного предиката, удаляющего один самый старый элемент базы. Первый вопрос ПО-формулы с системным предикатом будет выглядеть так:
\begin{equation}
	\forall n,x,y\colon f(n,x),f(n+1,y) - \exists\colon f(n+2,x+y)'(n+2), remFact(n)
\end{equation}

при этом запись $'(L)$ означает «пометить терм меткой L». Соответственно база данной ПО-формулы выглядит так:
\begin{equation}
\exists\colon f(1,1)'1, f(2,2)'2  
\end{equation}

Удаление элементов из базы можно организовать без использования меток атомов, если использовать RemPatternFact:
\begin{equation}
	\forall n,x,y\colon f(n,x),f(n+1,y) - \exists\colon f(n+2,x+y)'(n+2), remPatternFact(f(n,_))
\end{equation}

Символ подчеркивания интерпретируется как и в Прологе в качестве анонимной переменной. Из базы будут удалены все факты, являющиеся основными примерами  $f(n,_)$. Нетрудно заметить, что такой подход эквивалентен предыдущему, однако не требует дополнительных меток атомов.

\textbf{Косвенное управление.} Вывод (в смысле, ввод/вывод данных) некоторой системной информации, косвенно можно отнести к управлению логическим выводом. Поскольку данная информация может интерпретироваться пользователем или возможно иной программой управления ЛВ, как некоторые входные данные для принятия решения. Среди выводимой информации отметим следующие: текущий шаг вывода, имя базы, имя вопроса, ответная подстановка, количество фактов в базе, количество опровергнутых баз, количество вопросов, количество потенциальных ответов, время ЛВ и печать некоторых термов.

\paragraph{Вычислимые термы.} При решении прикладных задач может быть что заранее известна семантика формулы, область интерпретации и т.д. Отсюда некоторые сложные термы можно просто вычислять, а не выводить классическим образом, или как в случае с равенствами не использовать апарат перписывания термов или кодированых деревьев. Для этого каждому символу сигнатуры должна быть поставлена в соответствие некоторая функция.

Для обобщенного терма реализован метод GTerm reduce() вычисляющий его значение. Вычисление допустимо если всего его аргументы являются также вычислимыми термами, а все переменные и НЭЭ связаны. В соответсвии со строковым представлением символа, ему задаётся его семантика в виде лямбда выражения.


%------всякие дополнительные плюшки
\section{Язык и трансляторы формул} 

\subsection{Язык формул для прувера}
БНФ?

\subsection{Транслятор из формул ИП в ПО-формулы}
Алгоритм трансляции. 

\subsection{Транслятор из TPTP в ПО-формулы}
Для представления формул на языке предикатов первого порядка используется формат представления формул библиотеки TPTP.

\section{Интерпретация полученных результатов}
С каждым узлом ДСВ связывается некоторе событие (сообщение). В каждый момент времени по текущену состоянию ДСВ можно интерпретировать что же произошло, путём последовательного вывода сообщений начиная от корня и заканчивая листом, для каждой базы.


%-----------интерактивные возможности
\section{Интерактивные возможности}
Например, при решении задачи о лифтах надо как-то добавлять информацию о поступающих выводах извне.

Как-то надо совместить это с Миниязычком.

%========================= КОММЕНТАРИИ ====================
\section{Комментарии по предложенным стратегиям}
Анализ методик показывает, что структура вывода --- ДСВ тем более эффективна и тем выше её КПД чем больше элементов может содержаться в чанках. Размер чанка зависит от соответствующих консеквентов формулы. В терминах языка ПО-формул, более предпочтительными являются формулы имеющие как можно более крупные конъюнкты, и формулы имеющие глубину. Анализ задач из библиотеки TPTP показал что такой-то класс задач при формализации в языке ПОФ обладает описанным свойством.

При классическом подходе поскольку должны быть опровергнуты все базы, не стоит пытаться опровергать их одновременно, разростая тем самым дерево, можно сэкономить память строя однобокое дерево и доказывая всегда одну ветвь, таким подходом можно увеличить глубину пространства поиска.


%-----------------------------------------------------------------------------------------
%---------------------Интерфейс------------------------------------------------
%-----------------------------------------------------------------------------------------
\section{Интерфейс и спецификация}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "dis"
%%% End: 

