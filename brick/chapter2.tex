\chapter{Алгоритмическое обеспечение и адаптация алгоритмов}

В этой главе рассматривается задача адаптации существующих алгоритмов, используемых в различных системах АДТ для повышения производительности процесса поиска логических выводов, \app{а также разработка других специализированных алгоритмов}. Задача этой главы -- реализовать полезные свойства ПО--исчислений при помощи известных мощных алгоритмов поддержки различных этапов построения логических выводов. В качестве таких алгоритмов выбраны \rem{...}{Можно перечислить имена,   ссылки на литературу} В результате адаптации получены \rem{...}{Что в результате получилось/удалось? }

%==========================================================
\section{Предпосылки разрабатываемых алгоритмов}

Для того что бы алгоритмы адекватно использовали возможности ПО--формализма необходимо выявить его совместимые полезные свойства, а также свойства, не совместимые с адаптируемыми алгоритмами.  Полезные свойства, которые обеспечены алгоритмически в рамках данной диссертации представлены во введении.

%--------------------ПРОБЛЕМЫ------------------------------------
\subsection{Проблемы формализма ПО-формул}
Укажем на некоторые свойства ПО-формализма, сказывающиеся на \rem{производительности процесса поиска ЛВ и ...}{Как оно сказывается?} в частичном разрешении которых он нуждается.

\begin{enumerate}

\item Поиск ответов на вопросы с открытыми переменными требует выбора   подставляемого терма для данной переменной из эрбранова универсума,   который, в общем случае, т.е. при наличии функциональных символов, является бесконечным множеством (счетным множеством). Какой именно терм необходимо выбрать --- изначально неизвестно.

Сделаем несколько замечаний. Во-первых, при решении прикладных задач, переменные связанные квантором всеобщности ограничиваются типовым условием, а значит появление открытых переменных в данном случае следует рассматривать как некую аномалию в следствии неверной формализации задачи. Это значит, что решение данной проблемы лежит вне прикладной области, и необходимо для решения общематематических теорем, например, из библиотеки TPTP.  Во-вторых, есть соблазн уйти от функциональных символов (как это скромно сделано в \cite{Vas_ICDS}), но наличие функциональных символов есть основа сложных задач. В-третьих, в \cite{Vas_ICDS} предложена идея стратегии решения данной проблемы --- стратегия отсроченного присваивания (СОП), заключающаяся в том что изначально для открытой переменной выбирается неопределенный эрбранов элемент, а позднее он постепенно доопределяется. Подробное описание стратегии и её реализация представлены в главе 3. Данная стратегия конфликтует с другими стратегиями. Однако анализ решаемых задач показывает что в \app{указанных} прикладных задачах нет нужды использовать СОП, т.к. в их формальном представлении нет открытых переменных. В общих же задачах сложнее найти какие-то особенности, которые применяются другими стратегиями, а значит конфликт частично разрешается просто разграничением областей применения \rem{системы}{Или же алгоритма   поиска подстановки для НЭЭ?}.

\item Язык ПО-формул в \cite{...} характеризуется как <<достаточно   однородной, но в то же время хорошо структурированный>>, а \app{его исчисления}  <<хорошо усваивают эвристики>>, т.е. базовая стратегия исчисления достатосно легко настраивается под конкретную задачу. Стоит заметить, что однородность ПО-формул \rem{хуже}{В каком смысле? По отношению к чему? критерий.} чем, например, однородность дизъюнктов, в силу \rem{разнородных}{большего разнообразия?} сущностей в структуре формулы: база, вопросы, консеквенты вопросов. Разрешение \rem{данного вопроса}{Какого? Я не понял.} требует применения специальных методов доступа к \rem{данным неоднородным частям}{неоднородным частям ПО--формулы?}.

\item Хотя изначально представление формулы ИП в языке ПО--формул более компактно чем КНФ, применение правила вывода в ходе построения ЛВ при наличии дизъюнктивного ветвления, в общем случае, приводит к б\'{}ольшему усложнению структуры формулы, чем при применении правила вывода \rem{в МР}{или просто ``MP''?}. Таким образом, через некоторое количество шагов вывода размер ПО--формулы может оказаться в разы больше чем размер соответствующей КНФ. Но эта проблема практически полностью устранима технически, а именно описанными далее методами разделения общей оперативной памяти данных, а также ограничивающей стратегией, которую пользователь выбирает сам.
\end{enumerate}


%---------------------------
\subsection{Постановка задачи}
Поскольку в данной работе рассматривается первопорядковый язык ПО--формул, некоторые из структур данных и алгоритмов имеют сходства с уже существующими системам АДТ первого порядка. Это касается структуры термов и представления подстановок. Кроме того, существуют общетехнические методы \app{решения конкретных технических задач}, не зависящие от реализуемого формализма, например параллельные схемы алгоритмов, экономия потребляемой памяти, индексирование данных. Таким образом, в работе осуществлена адаптация некоторых существующих алгоритмов, используемых в современных эффективных системах АДТ. Адаптация предполагает, во-первых, учет особенностей ПО--формализма, как совместимых с данными алгоритмами, так и проблемных; во-вторых, \app{реализована} задача обеспечения совместимости адаптируемых алгоритмов, поскольку некоторые из них конфликтуют друг с другом при прямой независимой реализации.



%===============================================================
%---------------------------------------------------------------
%-----------------------АЛГОРИТМЫ---------------------------
\section{Алгоритмы и структуры данных}

%===================базовые структуры данных========================
\subsection{Общие структуры данных}

\app{Это реализация или алгоритмы, причем тут типы? Алгоритм+Стр. данных = Программа (Вирт))}
\app{Оговорить, что далее понимается под языком. ... ``используемый язык''...}
\textbf{Типы данных.} \rem{...}{Надо ранее, перед этим абзацем сказать, что значит здесь ``тип данных''. Или это идет речь о тегоровании структур данных?} Язык представления формул имеет следующие типы данных: ATOM (атомарный символ), FUNCTION (функциональный символ), CONSTANT (константный символ), AVARIABLE (универсальная переменная), EVARIABLE (экзистенциальная переменная), UHE (Неопределённый Эрбрановский Элемент), INTEGER (целочисленный символ), FLOAT (нецелочисленный символ), STRING (строковый символ). Данные \rem{типы}{Значения теговых полей структур?} определяются перечислением:

{\tt enum SymbolType {CONSTANT, EVARIABLE, AVARIABLE, FUNCTION, ATOM, INTEGER, FLOAT, STRING, UHE};}

\textbf{Символ (Symbol).} Символ -- это \rem{буква}{идентификатор? почему одна буква?} из алфавита \app{используемого языка}. Структура \texttt{Symbol} содержит строковое представление символа, тип данных, арность. Символ идентифицируется его адресом в оперативной памяти ЭВМ.

\textbf{Обобщённый терм (GTerm).} Идея использования структуры взята из \cite{NNN}. Данная рекурсивная структура данных используется как для представления термов, так и атомов, в виде деревьев. Для \rem{правильной}{В каком смысле?} обработки \rem{соответствующих}{чему?} обобщенных термов используются вышеописанные \rem{типы данных}{Вот надо подробнее в этом предложении. Расписать на абзацы.}. Терм представляется классической рекурсивной древовидной структурой каждый узел которой содержит символ \app{\texttt{GTerm}} верхнего уровня и массив ссылок на дочерние узлы. Универсальная переменная (AVARIABLE) и неопределённый эрбрановский элемент (UHE) используют один \rem{дочерний узел}{Или первый элемент одноэлементного массива аргументов?} как ссылку на терм, который подставляется вместо термов AVARIABLE и UHE. Если эта ссылка указывает не на терм UHE, значит эта переменная/\app{НЭЭ} связана с некоторым термом. В противном случае переменная/\app{НЭЭ} является свободной для подстановки. Ссылка из переменной/НЭЭ может быть разыменована, что достигается при помощи метода getValue(), который возвращает значение типа GTerm. Если переменная/НЭЭ не связана с другими термами, то значение getValue() совпадает со ссылкой на \rem{эту}{Логичнее было б NULL, и оптимизировать проверку можно было б} переменную/НЭЭ, в противном случае возвращается ссылка на терм с которым связана переменная.

\textbf{Чанк} --- это специальным образом маркированный список. Список разделён на подсписки некоторой длины, в том числе и нулевой. Задана процедура, определяющая для каждого элемента списка к какому подсписку он относится. В каждом чанке хранится информация о текущем шаге вывода, а весь список в целом хранит всю информацию о \rem{формуле}{или выводе?}. Т.е., формула --- это \rem{список}{Откуда взялся список? До этого момента его, вроде, нет.}, а чанк --- это \rem{подформула}{этой формулы?}, полученная на определённом шаге вывода. На рисунке \ref{fig:chank1} представлена \rem{структура}{Или пример структуры?} чанкового списка.

\begin{figure}[h]
	%\vspace{0.5cm}
	\centering
	\includegraphics[width=0.6\linewidth]{pics/Chunk.eps}
	\caption{Чанковый список}
	\label{fig:chank1}
\end{figure}
\app{Здесь, \texttt{first} и \texttt{last} --- \rem{...}{Что это? Можно побольше прокомментировать.}; \texttt{chunk X} --- ...}
На следующем рисунке показан \rem{случай}{Чем он так замечателен? Когда он образуется и как?} когда один из чанков пуст.

\begin{figure}[h]
	%\vspace{0.5cm}
	\centering
	\includegraphics[width=0.6\linewidth]{pics/Chunk2.eps}
	\caption{Чанковый список, содержащий пустой чанк}
	\label{fig:chank2}
\end{figure}

\rem{Стоп}{Щё сие значит?}.


%=================== ДЕРЕВО СОСТОЯНИЙ ВЫВОДА =======================
\subsection{Дерево состояний вывода}
Одним из основополагающих средств реализации поиска ЛВ в разработанной системе АДТ является дерево состояний вывода (ДСВ), которое строится при помощи \rem{...}{Каких-то там} структур данных. В структурах ДСВ \app{сохраняется история} логического вывода. Основная задача ДСВ заключается в том, чтобы строго зафиксировать все события, произошедшие на каждом шаге логического вывода. \app{Примером фиксируемого события является факт применения некоторой подстановки к в некоторой базовой подформуле к некоторому вопросу}. Такая фиксация событий позволяет:
\begin{enumerate}
 \item Более \rem{глубоко}{Это метафора. Можно уточнить? ``Использовать больше информации о выполненных действиях''.} анализировать процесс ЛВ, а значит эффективно (\app{в смысле большего разнообразия вариантов управления}) внедрять эвристики в базовую стратегию поиска ЛВ.
 \item Производить поиск с возвратом (backtracking) в процессе построения ЛВ.
 \item Реализовать \rem{один}{Какой именно?} из подходов разделения данных.
 \item Производить \rem{эффективное}{В смысле программирования прувера или по скорости освобождения?} освобождение памяти.
\end{enumerate}

Идея использования ДСВ базируется на анализе свойств классического подхода \rem{к}{Чему?}. После каждого ответа на вопрос к \rem{первоначальной формуле}{базе? базовой подформуле?} добавляется \app{частный случай} консеквента этого вопроса: в базу добавляются соответствующие элементы узлов, непосредственно следующих за вопросом; к \app{имеющемуся списку вопросов к базе}, в общем случае, добавляются новые вопросы; в случае дизъюнктивного ветвления \rem{соответствующая}{Убить слово?} база расщепляется \rem{, не теряя никаких данных}{Это реально ннада?}.
Таким образом, формула монотонно увеличивается \rem{, при этом сохраняя свою структуру}{В каком смысле?}. ДСВ будет использоваться для того, чтобы всегда иметь доступ к полной информации о \app{текущем и прошлом состоянии} формулы, а также для возможности возврата поиска вывода (backtracking) и подробного \rem{наблюдения}{Какая-то статистика собирается?} за процессом поиска ЛВ.

Более детально дерево состояний вывода есть такое дерево, которое обладает следующими свойствами: корень дерева есть одна из базовых подформул исходной ПО--формулы; все остальные узлы есть добавляемые консеквенты с примененным к ним подстановками--ответами и необходимым разыменованием переменных. Если приводить в пример определение правила вывода, то корень дерева --- это база \rem{E, а узлы это $E2\theta$}{Лень формулу написать?$\exists\theta$}. Таким образом если происходит расщепление базы то в соответствующем узле появляется ветвление. Теперь можно говорить, что каждая базовая подформула в формуле характеризуется соответствующим путём от листа ДСВ до её корня.

Как видно, каждый узел содержит достаточную информацию и для того, чтобы производить возврат поиска, для этого достаточно просто удалять соответствующие \rem{узлы}{А править состояния??}. Кроме того, такой подход реализует разделение данных (ссылок) на каждый консеквент, поскольку некоторые пути могут иметь общие подпути. Если какая-то база опровергнута, то можно удалить все узлы от соответствующего листа до ближайшей точки ветвления, поскольку оставшаяся часть пути всё ещё используется для представления другой базы. Количество \app{листовых} узлов равно текущему количеству баз. Если дерево пусто, значит первоначальная база опровергнута. Та как изначальная формализация задачи в языке ПО-формул может содержать несколько базовых подформул, то для каждой из этих подформул строится \rem{своё}{А одно корневое фиктивное ветвление нельзя?} ДСВ.

Для \rem{практических нужд}{Этот абзац непонятен на 80\%. Картинку в студию!} узел ДСВ содержит некоторую системную информацию:
\begin{enumerate}
\item Множество атомов, понимаемых как часть базовых, отсюда каждый базовый конъюнкт характеризуется объединением всех множеств от данного узла до корня.
\item Список ссылок на вопросы к базе.
\item Для каждого вопроса определяется чанк ответов для вопроса в данный момент.
\item Номер последующего шага вывода и соответствующий ответ, если узел имеет потомков.
\item Чанк уже отработанных вопросов.
\end{enumerate}
Кроме того, узлы ДСВ содержат разнородную информацию, используемую как параметры к стратегиям поиска логического вывода.

При помощи чанков получается \rem{разграничивать}{Разделять - понятно что такое. А что такое разграничивать?} \rem{данные}{Что за данные?} полученные на каждом шаге, с другой стороны на каждом шаге (в каждом узле) доступны все собранные до этого \rem{данные}{Предложение требует обдумывания.}.

ДСВ для формулы из \rem{примера}{Какого? который был ранее?} представлено на рисунке рис.~\ref{fig:pst}. Корнем ДСВ является исходная ПО--формула $F_1$. Узел ``2" является консеквентом вопроса $Q_1$, а именно $\exists\colon A(a)$, а путь от узла 2 до корня соответствует ПО-формуле $F_2$. Узлы 3 и 4 соответствуют консеквентам вопроса $Q_4$. Путь от узла 3 до корня и путь от узла 4 до корня соответствуют базовым подформулам ПО--формулы $F_3$. Например, формулы определённые путями 5 --- 1 и 3 --- 1 разделяют данные, которые представлены узлами 1 --- 2. Если базовая подформула, которая представлена узлами пути 3 --- 1 опровергнута, то можно удалить путь от узла 3 до ближайшего ветвления (в сторону корня), в данном случае удаляется только узел 3, поскольку узлы 2 --- 1 всё ещё используются для представления других базовых подформул.

\begin{figure}[h]
	%\vspace{0.5cm}
	\centering
	\includegraphics[width=0.4\linewidth]{pics/PST.eps}
	\caption{Дерево состояний вывода для формулы из примера \ref{proofexample}.}
	\label{fig:pst}
\end{figure}

На следующем рисунке представлено ДСВ с точки зрения его \rem{связи}{Что за связь} с чанками.

\begin{figure}[h]
	%\vspace{0.5cm}
	\centering
	\includegraphics[width=0.6\linewidth]{pics/PST2.eps}
	\caption{ДСВ рис.~\ref{fig:pst}, \app{представленное в виде чанков}}
	\label{fig:pst2}
\end{figure}

\rem{С точки зрения реализации ДСВ растёт от листов к корню}{Не понял. Причем тут реализация? \app{М.б. это просто свойство структуры, как, например, в Linux директорий /var всегда растет.}}.


%================================== СУПЕРВИЗОР =======================
\subsection{Супервизор}
Супервизор \que{наблюдает} глобально за всем \rem{деревом}{Каким деревом? ДСВ или ПО--}, обеспечивает алгоритмы информацией об ограничениях ресурсов, используемых эвристиках и т.п. В супервизоре находится список всех текущих листов дерева \app{ДСВ}. Большинство стратегий реализовано на уровне супервизора, поскольку, в общем случае, необходимо использовать информацию о всей совокупности предшествующего или \rem{последующего вывода}{Вот коряво то, что прошлое и будущее симметричны... + Надо детально написать здесь, какая информация предоставляется эвристикам.}.

Наличие такого \rem{субъекта управления}{=СУпервизор, новая сущность?} обусловлено тем что некоторые частные события в процессе логического вывода могут повлиять на \rem{него}{Субъект или управление?} в целом.

%================================== ОГРАНИЧЕНИЕ РЕСУРСОВ =======================
\subsection{Стратегия ограниченных ресурсов}
Стратегия ограниченных ресурсов реализована в большинстве современных систем АДТ, в том числе и в Вампире \cite{}. В данной системе подобная стратегия \que{напрямую} зависит от текущего ДСВ и описывается следующим образом. Ветка ДСВ растет до тех пор, пока не наступит ограничение объема оперативной памяти, разрешенной для использования, либо пока не исчерпается определенное время, либо пока не будет произведено определенное количество шагов вывода. Если наступил предел использования ресурсов, то \rem{необходимо произвести}{Или осуществляется...} откат назад и \rem{попробовать}{осуществить попытку применения других ответов} другие ответы, т.е. получить другие варианты построения дерева.

%============================================================================
%================================== РАЗДЕЛЕНИЕ ДАННЫХ =======================
\subsection{Разделение общей оперативной памяти структурами данных}
Логический вывод, как правило связан, с получением новой дополнительной информации, ростом объема используемой оперативной памяти. Например, в \rem{МР}{МР(Метод Резолючии)=MP (Modus Ponens) крайне неудачно получилось...} выводятся (синтезируются) новые дизъюнкты до тех пор пока не получится пустой дизъюнкт, а в методе доказательства ПО-формул производится насыщение баз фактами до тех пор, пока они не станут противоречивыми. Поскольку сложность формул может быть сколько угодно большой и даже минимальный вывод может иметь сколько угодно большую длину, имеет место проблема исчерпания имеющихся ресурсов вычислительной системы на хранение разрастающиеся структуры формулы. Опыт показывает \ref{reference}, что автоматический вывод довольно быстро занимает всю имеющуюся в распоряжении оперативную память, и далее процесс вывода требует регулярное удаление \rem{излишков}{Надо уточнить, что за излишки.}. Таким образом, проблема экономии оперативной памяти является важной, особенно с \que{учётом увеличения сложности задач}.

Для экономии памяти используются, во-первых проектирование компактных структур данных; во-вторых, методы разделения общих участков оперативной памяти (data sharing). В случае логических языков и конкретно языка ПО--формул использование методик хранения информации с разделением общей памяти является актуален. Исходя из некоторых общих особенностей представления языков первого порядка и представления ПО--формул, выделено и реализовано четыре методики разделения данных.

\rem{...}{Будем говорить о каком-либо специальном менеджере
  оперативной памяти?}

\paragraph{Агрессивное разделение термов.} Заключается в том, что разделяются общие участки оперативной памяти среди термов. Например, в термах $A(g(a,f(x)),h(c))$ и $B(k,g(a,f(x)))$, подтермы $g(a,f(x))$ являются общими и представляют собой один и тот же участок в памяти. Данный подход позволяет достаточно экономить большие объемы оперативной памяти при ограниченных ресурсах, однако требует дополнительное процессорное время на вычисление общих подтермов. Такой метод является общеупотребимым в системах АДТ, классически варианты реализации представлены в \cite{}.

\paragraph{Мягкое разделение термов.} Отличается от агрессивного подхода намного меньшим потреблением процессорных ресурсов, но и меньшей эффективностью с точки зрения объема экономии памяти,
поскольку разделяет только часть общих подтермов. Исходя из определения \ref{ircond} применение правила вывода $\omega$ \app{корректно} в случае выполнения условия $A\theta \subseteq B$, где $A$ и $B$ соответственно конъюнкты вопроса и базы. Поскольку $B$ это уже существующее множество \rem{основных обобщенных термов}{Будем уточнять после вчерашнего разговора про НЭЭ?}, то для их хранения выделена соответствующая оперативная память. Подстановка $\theta$ же является отображением переменных вопроса $A$ в элементы эрбранова универсума. В дальнейшем при выполнении шага вывода $\theta$ применяется (апплицируется) ко всему консеквенту вопроса, и данный консеквент добавляется к формуле. Однако правая часть подстановки уже имеется в оперативной памяти в силу того, что основана она на термах из $B$. Исходя из этого, достаточно использовать ссылки на структуры и уже имеющуюся память, используемые для правых частей подстановки в тех частях консеквента, где эта подстановка применяется. На рис.~\ref{} детально представлен пример, демонстрирующий данную ситуацию.

\paragraph{Разделение базовых подформул.} ПО--формулы, в которых производится ответ \rem{на вопрос, имеющий вопрос}{Один или два вопроса. Или это последовательность вопросов?} с дизъюнктивным ветвлением, расщепляются на несколько новых базовых подформул. Количество новых базовых подформул совпадает с количеством непосредственных дизъюнктивных подформул в консеквенте вопроса. В простом варианте реализации ЛВ такое расщепление требует копирования предыдущего состояния формулы несколько раз; такое копирование естественно приводит к большим затратам памяти и процессорного времени, затрачиваемого для копирования. Разделение базовых подформул вполне реализуемо при помощи агрессивного разделения оперативной памяти термами. Однако, если формула предполагает достаточно сильное ветвление, сохраняется проблема наличия множества ссылок на разделяемые атомы баз. Поскольку расщепление предполагает разделение общих частей баз, то имеет смысл разделять \rem{именно эти ссылки}{...на что?}. Более подробно ситуация рассмотрена на рис.~\ref{}.

Таким образом, в системе кроме разделения термов используется ещё и разделение ссылок на эти термы, благодаря ДСВ. \rem{...}{Вот не понятно, причем тут ДСВ и ссылки на ссылки, ссылки на термы. Надо подробнее.}

\paragraph{Разделение переменных и неопределенных эрбрановских элементов.} Данная методика предназначена для высокопроизводительного применения подстановки ко всей подформуле, т.к. все одноименные переменные в формуле представляют собой один участок в оперативной памяти. О неопределенных эрбрановских элементах сказано \rem{ниже}{А надо выше, после GTerm}. Все одноименные переменные на протяжении любого основного пути формулы \cite{dissChe} являются указателем на один и тот же участок в памяти. В отличие от агрессивного разделения данный подход учитывает роль переменных в процессе поиска ответных подстановок. В процессе применения подстановки переменная не заменяется на терм, а лишь указывает на этот терм, что позволяет экономить время на замену переменной термом в поддереве: достаточно одной операции присвоения над одной переменной, чтобы установить замену всех таких переменных в поддереве.

\paragraph{Веса подформул.} Под весом терма или подформулы понимается количество узлов в дереве, представляющем терм или подформулу. Анализ веса позволяет сдерживать разрастание формулы, и, соответственно обеспечить дополнительную экономию потребляемой памяти. Для этого из возможных ответов на вопрос выбирает \app{сначала} тот, который приводит к формуле наименьшего веса.

\rem{...}{Что насчет управления комбинациями методик? Откат и вес? Как задавать эти комбинации? ли это уже реализация, наверное.}

%======================== INDEXING ===========================
\subsection{Индексирование данных}

Из определения \rem{стратегии}{Какой точно стратегии?} ясно, что шаг вывода зависит от некоторых \textbf{критериев}\rem{...}{Оценки структуры подформулы?}, которым должны удовлетворять определенные части ПО--формулы. Например, допустимы следующие критерии: наличие в базе заданного терма, наличие вопроса с заданными свойствами, количество вхождений \rem{терма}{оговорил, что мы из термов коньюнкты делаем, а не из атомов.} в конъюнкт и т.д. Для определения \rem{истинности данных критериев}{обычно критерии числовые. М.б. это не критерии а индикаторы?} необходимо проводить поиск и анализ \rem{данных}{Каких именно?} в формуле. \que{С каждым шагом вывода формула в общем случае увеличивается (причем в некоторых случаях довольно быстро), и может настать момент когда поиск тех или иных данных будет затруднен.}

%индексирование термов
\paragraph{Индексирование термов}

В информационных технологиях подобные \rem{проблемы}{Я вот не понял проблему? оценка критериев? Борьба с разрастанием формулы? или что-то там про стратегию упомянуто было?} разрешаются с помощью методов индексирования данных, применяемых широко в реляционных базах данных \cite{Ulman}. \rem{Подобно тому как в библиотеке книги проиндексированы первыми буквами своих названий а также именами авторов.}{Сие примитивно, и не представляет интереса профессионалам, которые это будут читать.}
\rem{...}{что мы будем ускорять? Доступ к термам? Ускорять ли...}

В нашем случае основной объект индексирования --- это терм, который является древовидной структурой, индексирование которой методами, используемыми в  реляционных БД, неэффективно [есть ссылка на это]. Поэтому следует использовать иные подходы. \rem{...}{Этот абзац не о чем, Зачем писать о том, что не будет использоваться?}

Индексирование термов к настоящему времени хорошо исследовано, как в рамках определенных систем АДТ, так и абстрактно. В частности по данной теме существует ряд интересных работ, в том числе [дискриминационное дерево и пути, подстановочное дерево, и книжку Графа про индексирование]. \app{Представленные в этих работах методы}, позволяют эффективно находить в базе термов те термы, которые удовлетворяют определенным критериям: являются равными данному (query term), являются его примерами, обобщениями (generalization) и унификациями. Для наших нужд не требуется \rem{обобщение и классическая унификация}{Обновить надо?}, но дополнительно необходимы методы индексной поддержки НЭЭ-унификации: критерий наличия термов, включающих заданный подтерм; различные количественные критерии: вес, глубина, арность. С учетом перечисленных требований а также того факта, что как правило, в базе находятся основные \rem{термы}{Через абзац будет использоваться ``основной пример'' кругом.}, качестве основы методики индексирования выбрано индексирование путями []. Кратко опишем её суть, как она описана в [].

Для каждого атома составляется список так называемых \emph{путей}. \rem{...}{Надо привести формальное определение пути из [макКьюн]]}. Например, атом $A(g(x,c),e)$ представляется в виде путей $A$, $A1g$, $A1g1x$, $A1g2c$, $A2e$. Каждый из этих путей содержит указатель на соответствующей \rem{атом}{Какой ``соответствующий''?}. Сами пути хранятся в отсортированном виде (в дереве).

Пример. Пусть дан атом $A(a,f(x,b))$ и множество атомов $\{A(a,f(c,b)), A(a,f(b,e)),A(a,f(k,b)), A(b,f(e,b))\}$. Любой атом, являющийся основным примером для заданного, содержит в своём списке путей следующие пути: $A1a$, $A2f2b$. Таким образом, для поиска основных примеров заданного атома необходимо найти пересечение множеств атомов, на которые указывают пути.  В частности путь $A1a$ указывает на множество $\{A(a,f(c,b)), A(a,f(b,e)),A(a,f(k,b))\}$, а путь $A2f2b$ на $\{A(a,f(c,b)), A(a,f(k,b)), A(b,f(e,b))\}$. Пересечение этих множеств есть множество $\{A(a,f(c,b)),A(a,f(k,b))\}$, это и есть множество примеров для атома $A(a,f(x,b))$. Методы индексирования термов в настоящее время широко используются во многих известных системах АДТ [Vampire -улучшенное индексирование путями, Otter -дискр.дерево и пути, E, EQP, SPASS -дерево подстановок].

Кроме базы термов, в индексировании нуждаются множества вопросов и множества ответных подстановок.

%индексирование других частей формулы
\paragraph{Индексирование других частей формулы}
Теперь опишем другие \app{проблемы, решаемые при помощи} индексирования. Предположим что \rem{пользователем}{Надо про него   что-то сказать, хотя бы во введении. Его участие в АДТ.} задана некоторая стратегия для решения некоторого класса задач. Стратегия оперирует вопросами с определенными свойствами (т.е. вопросу сопоставляется содержательная информация), которые присущи всему классу задач (т.е. все задачи объединяет наличие определенных вопросов). Для повышения производительности поиска ЛВ необходимо упростить в дальнейшем доступ к таким вопросам, чтобы каждый раз не \app{пере}проверять все вопросы на наличие определенного свойства. Для этого достаточно сделать словарь (map) в котором каждому \rem{описанию вопроса}{Что за описание? как оно соответствует критериям и индексированию? Это реализовано? Если да, то почему в сослагательном наклонении?} соответствовал бы указатель на данный вопрос. \rem{В принципе, в стратегиях задавать опции при помощи номеров вопросов, но тогда теряется гибкость: пользователю необходимо ставить вопросы всегда на одно и тоже место. Данный вид индексирования (весьма простого) может выполняться как на этапе компиляции (тогда в компиляции прувера будет задействован не только стратегия но и сама задача), так и при первичном обращении к вопросу (тогда нет необходимости в компилировании самой задачи).}{О чем это?}

%================================== ЛЕНИВАЯ КОНКРЕТИЗАЦИЯ =======================
\subsection{Неограниченные переменные}
Проблема неограниченных переменных описана \rem{выше}{Повтори в двух словах, а то я уже забыл. }. Для её решения предложено несколько подходов.

\paragraph{Ленивая конкретизация}
Суть ленивой конкретизации заключается в следующем. \app{При поиске подстановки} для открытой переменной (\app{переменной без атома в типовом условии}) выбирается не конкретный элемент эрбранова универсума, а в место этого она заменяется на неопределенный эрбрановский элемент (НЭЭ), который, в дальнейшем, исходя из \rem{нужд}{Вот подробнее? Какие нужды?} вывода, \rem{постепенно}{Это ``постепенно'' опиши в след. предложении.} доопределяется до основного терма, либо в некоторых ситуациях так и остается недоопределенным. По своей природе НЭЭ схож со [\app{свободной}] переменной в том смысле, что он \rem{изменяем}{Уточни термин.}, однако все такие изменения должны быть направлены \app{только} на конкретизирова\app{ние} НЭЭ, т.е. НЭЭ заменяется только на некий терм (возможно тоже содержащий НЭЭ), либо на другой НЭЭ, но не на переменную. Однако, при замене переменной на НЭЭ, НЭЭ обладает \app{всеми} свойствами терма.

Рассмотрим пример приложения этой техники в процессе построения \rem{логического вывода}{Вывод ли это? или просто кусок формулы.} следующей формулы.
\begin{equation}
	\forall\colon\boldsymbol{True} - \exists\colon\boldsymbol{True} -
	\left\lbrace
	\begin{array}{l}
		\forall x\colon\boldsymbol{True} - \exists\colon A(x) \\
		\forall x\colon A(f(x)) - \exists\colon B(f(x)) \\
		\forall\colon B(f(a)) - \exists\colon \boldsymbol{False}
	\end{array}\right.
\end{equation}
На первом шаге вывода получен ответ $\{x \rightarrow h_1\}$ на первый вопрос, $x$ является неограниченной переменной, $h_1$ --- это неопределённый эрбрановский элемент (НЭЭ). После первого шага атом $A(h_1)$ добавляется в базу. На втором шаге вывода получен ответ $\{x \rightarrow h_2\}$ на второй вопрос, и $h_1$ конкретизируется до $f(h_2)$, после второго шага $B(f(h_2))$ добавляется в базу. Наконец, на третьем шаге получен тривиальный ответ на третий вопрос, и $h_2$ доопределяется до $a$.

Однако существуют особые ситуации. Рассмотрим следующий пример.
$$\fictAquantor \; - \; \exists\colon M(e) \left\{
\begin{array}{lcl}
 \forall x,y\colon M(x) & - & \exists\colon S(y),M(f(x)),T(x) \\
 \forall x \colon T(x),S(e) & - & \exists\colon Q(x) \\
 \forall x \colon Q(x),S(f(e)) & - & \exists\colon\textbf{False}
\end{array}
\right.$$

Данная формула имеет вывод, например такой. Получаем ответ на первый вопрос подстановкой $\{ x\rightarrow e, y\rightarrow e \}$, в результате в базу попадают факты $S(e),M(f(e)),T(e)$; ответ на второй вопрос есть $\{ x \rightarrow e\}$, и в базу попадает $Q(e)$; полученных фактов в базе недостаточно для ответа на целевой вопрос, поэтому вновь отвечаем на первый вопрос, при этом возможно несколько вариантов ответа, но, что важно, переменную $y$ необходимо заменить на $f(e)$. Выберем, например, следующий ответ $\{x \rightarrow e, y \rightarrow f(e) \}$ и в базу попадет факт $S(f(e))$ после чего на целевой вопрос ответ получается. Заметим, что на первый вопрос необходимо обязательно выбирать те подстановки, которые содержат $y \rightarrow e$ и $y \rightarrow f(e)$, они необходимы для ответа на второй и третий вопросы, соответственно. Формула устроена таким образом что первый и второй вопросы всегда имеют новые ответы.

Теперь рассмотрим работу стратегии отсроченного присваивания. Ответ на первый вопрос будет следующего вида $\{ x\rightarrow e, y\rightarrow h_1 \}$, где $h_1$ --- НЭЭ, и в базу попадают следующие факты $S(h_1),M(f(e)),T(e)$. Ответ на второй вопрос --- $\{ x\rightarrow e, h_1\rightarrow e \}$, в котором $h_1$ доопределяется до $e$, и, соответственно, находящийся в базе факт $S(h_1)$ доопределяется до $S(e)$. С этого момента начинается \rem{зацикливание}{выполнение, фактически, циклической операции}, поскольку целевой вопрос не имеет ответа: вновь получаем ответ на первый вопрос, и вновь в базу попадает факт $S(h_1)$, который при ответе на второй вопрос вновь доопределится до $S(e)$ и т.д. Однако если пропустить ответ на второй вопрос, то при ответе на целевой, факт $S(h_1)$ доопределится до $S(f(e))$ и на этом вывод закончится.

В общем виде проблема заключается в том, что НЭЭ доопределяется при поиске ответов на определенный вопрос, раньше, чем это необходимо при ответе на другой вопрос. То есть, НЭЭ доопределяется там где этого уже не надо. Из подобных примеров видно, что СОП не может использоваться на прямую. Необходимы дополнительные средства обеспечения логического вывода. \rem{...}{Надо подработать этот абзац. Написать точнее: Доопределяется не так как требуется,... не там, где необходимо.}

\paragraph{Первый вариант}
Одним из вариантов решения проблемы является использование языка описания стратегий, с помощью которого можно, например, указать, что на второй вопрос необходимо ответить лишь один раз, либо использовать на первый вопрос сразу несколько подстановок содержащих $y\rightarrow h_1$ и $y\rightarrow h_2$. Это приведет к попаданию в базу двух фактов $S(h_1)$ и $S(h_2)$, один, из которых будет использоваться для второго вопроса, а другой для целевого. Такой вариант вполне приемлем, и предполагается что именно он и будет чаще всего использоваться для решения задач. \app{Такой подход в настоящее время пока не обеспечивает принципиальную выводимость, но для отдельных классов задач .....} \rem{Но что делать, если дополнительные знания о задаче не позволяют сформулировать правильную стратегию? Необходимо предоставить хотя бы принципиальную возможность вывода, что пока необеспеченно.}{Удалить м.б.}

\paragraph{Второй вариант}
Представим [\app{еще один}] путь решения описанной выше проблемы \rem{...}{У тебя их там штук 10 уже. Какой именно?} в общем случае, т.е. без использования дополнительных стратегий. Предлагается не доопределять НЭЭ \rem{на месте}{Уточни. ... как только построен ответ/во время построения ответа ....}, как это сделано \rem{выше}{Какой именно вариант? пред вариант? где именно?}, а порождать новые выражения, полученные из \rem{исходных}{Уточни, не понятно.}, заменой в них НЭЭ на доопределение\rem{...}{Не понятно. the доопределение? тогда какое?... мож я дуб.}. То есть, если в базе содержится факт $S(h_1)$, и $h_1$ необходимо\rem{...}{..когда-то..} доопределить до некоторого терма $t$, то в базу добавляется новый факт $S(t)$, порожденный от $S(h_1)$, при этом сам $S(h_1)$ сохраняется. При \rem{определенных условиях}{Пример приведи.} также может возникнуть ситуация, когда будут порождаться не только факты, но и целые подформулы.

Содержательно такой подход означает следующее. Можно считать что для вопроса с открытыми переменными применяется вся совокупность возможных ответов, т.е. с использованием всех элементов эрбрановского универсума. Понятно, что это технически нереализуемо из-за бесконечности эрбановского универсума, то используется техника ленивых вычислений. В идеале предполагается, что \rem{применены}{Уточнить можно?} все ответы, а на самом деле используются только необходимые.

Данный подход имеет и определенные недостатки. Это связано с тем, что если появится вопрос с НЭЭ, то придется порождать новые \rem{вопросы}{Пояснить}, а если в этом вопросе будет присутствовать дизъюнктивное ветвление, то возникает проблема \rem{...}{Какая?}. Кроме того, во время унификации появляется ряд проблем \app{... всякие проблемы. Короче об этом надо упомянуть но сильно не выпячивать, и оправдаться тем что мы больше нацелены на использование миниязычка, а эта стратегия дана лишь для обеспечения полноты вывода. Но эта стратегия вполне эффективна если НЭЭ не будут появляться новые вопросы с НЭЭ и в диз.ветвлении их не будет...} \rem{..}{Ты говорил о недостатках, описывал связанные с ними проблемы. Однако недостатки остались неопределенными. Если нелостатки=проблемы, то надо перефразировать.}

Отметим, что стратегии, основанные на использовании НЭЭ, \rem{стоят особняком}{Уточни. Конфликтуют или не конфликтуют, вмешиваются или не могут быть скомплексированы??} для многих других стратегий. Во-первых, при использовании этой стратегии нарушается независимость базовых подформул, поскольку один и тот же НЭЭ может быть в разных подформулах: доопределение общего НЭЭ в одной подформуле автоматически приводит к доопределению его в другой подформуле. Этот факт, в частности, делает зависимыми процессы поиска ЛВ в базовых подформулах на параллельных вычислительных архитектурах. Он также противоречит некоторым эвристическим уточнениям алгоритмов и стратегий, например, {...}{Пошел простой пример стратегии.}.

\paragraph{Третий вариант: стратегия фильтрации эрбрановского универсума}
Ещё одним вариантом решения проблемы \rem{открытых переменных}{или НЭЭ. Вопрос - ``третий вариант'' в заголовке раздела.} является стратегия фильтрации эрбрановского универсума. Данная стратегия позволяет избавиться от вышеперечисленных проблем, но несколько расширяет пространство возможных ответов. Суть данной стратегии заключается в следующем. Атомы консеквентов, которые (\rem{атомы}{У меня тоже не получилось убрать скобки!}) содержат неограниченные переменные вопросов, должны унифицироваться с одноимёнными атомами из всех других частей всей базовой подформулы, в противном случае атом попавший в базу не будет удовлетворять условию применения правила вывода (\ref{}), поскольку никода не выполнится процедура матчинга при поиске ответов. Будем использовать данное свойство в стратегии. В качестве ответа для неограниченных переменных используются основные примеры унификации. Такой подход позволяет заранее сузить пространство эрбрановского универсума, фильтруя заведомо бесполезные ответы.

Для ясности рассмотрим \rem{пример}{где он}.

%======================================================================
%================================== k,m-условие =======================
\subsection{Стратегия km-условия}
Данная стратегия формулируется следующим образом. Некоторый ответ применяется, если за последующие k шагов произойдет заданное событие m раз. Пользуясь терминологией ДСВ это означает что для данного узла дерева применяется ответ в случае если построенное в результате дальнейшего вывода поддерево коренящееся с этого узла не превысит глубину k и до этого момента произойдет m раз событие.

Мы предлагаем три спецификации данной стратегии.

\textbf{km-опровержение.} Ответ выбирается в случае если за последующие k шагов будет опровергнуто m баз. Подобная стратегия первоначально предложена в \cite{ICDS2000} и реализована в КВАНТе Черкашина. В данной системе эта стратегия расширена вторым параметром m. Она позволяет сдерживать разрастание пространства поиска вывода, т.е., сдерживает излишнее ветвление ДСВ, что в некоторых случаях приводит к многократному усложнению вывода.

\textbf{km-конкретизация.} Если за последующие k шагов будет доопределено m НЭЭ. Эта стратегия также направлена на то чтоб ограничить сложность представляемой формулы. Недоопределенный НЭЭ тащит много информации за собой и много условий, что на уровне реализации влияет негативно, поэтому чем больше и быстрее НЭЭ будут доопределены нужным образом, тем лучше.

\paragraph{Особенности реализации}
Основной для реализации данной стратегии являются описанные выше ДСВ и супервизор. Параметры k,m и собственно условие закладывается в супервизоре и привязывается к определённом узлу ДСВ. Через каждый следующий шаг вывода, супервизор проверяет все условия. И в положительном случае производится откат назад, т.е. последовательное удаление узлов дерево в обратном порядке (от листа в направлении корня). Перед удалением каждого узла производится разконкретизация НЭЭ полученных на этих узлах и возврат использованных вопросов в стадию активных (т.е. возможных для применения).

%================================== КЕШИРОВАНИЕ =======================
\subsection{Кэширование результатов}
Учитывая множественность возможных ответов, откатов в выводе, большой глубины вывода, большого количества атомов в базе и т.д. целесообразно кешировать некоторые результаты чтобы не производить снова повторяющиеся вычисления.

Добавление уже имеющихся в базе атомов не допускается. Поэтому процедура поиска ответов работает всегда с новыми атомами, и производит всегда новые вычисления. Тем не менее полученные ответы в итоге могут совпадать. Все примененные ответы сохраняются, причем хранятся они как и база в чанках, размазанных по всему пути от листа до узла. Это позволяет делать корректные откаты с учетом сохранения информации о примененных ответах.

%-----------PARALLEL STRATEGY---------------------------
\subsection{Параллельные стратегии}

Полезно сполна использовать все вычислительные ресурсы. Многие современные ВС обладают бОльшим чем 1 вычислительным элементом (процессором).

Предлагаем следующие стратегии для распараллеливания процесса логического вывода.

\paragraph{Первая стратегия}

В случае если вопрос имеет дизъюнктивное ветвление, то после ответа на этот вопрос, формула расщепляется и трансформируется в формулу с б'ольшим количеством баз. Таким образом, количество базовых подформул может заметно увеличиваться. Кроме того, исходная формализация задачи в языке по-формул может содержать более одной базовой подформулы. Для того, что бы показать, что исходная формула противоречива, необходимо опровергнуть каждую из баз. Специфика исчисления ПО-формул, позволяет рассматривать данные базы независимо друг от друга (естественный ИЛИ-параллелизм, следующий из того что в базах находятся лишь основные термы), а значит, процедура опровержения каждой базы может выполняться в отдельном вычислительном процессе. Таким образом, первая стратегия, реализуемая в виде параллельной схемы алгоритмов, формулируется следующим образом: каждая базовая подформула опровергается независимо, а значит параллельно. Для нужд данной стратегии как раз и реализовано жесткое копирование (следующая глава), что бы полностью скопировать базовую подформулу и обрабатывать её в отдельном процессе независимо (не разделяя память).

\paragraph{Вторая стратегия}
Для применения каждого шага логического вывода, необходимо выполнять, в общем случае, поиск ответных подстановок для заданного вопроса. Поиск ответных подстановок не изменяет структуру формулы, и не использует общих изменяемых данных, это значит, что процессы поиска ответа на каждый вопрос независимы, а значит параллельны.


\paragraph{Третья стратегия}
Теперь рассмотрим процедуру поиска подстановок для отдельно взятого вопроса.
Как было сказано во введении, подстановка $\theta$ является ответом, если выполняется
условие $A\theta \subseteq B$, где $B$ --- конъюнкт вопроса, $A$ --- конъюнкт базы.
Для сохранения полноты необходимо хотя бы потенциально иметь в распоряжении все возможные ответы,
из которых выбирается подстановка для данного шага. Ниже описан структура хранилища ответов. Можно говорить о том что наполнение каждого чанка хранилища подстановками производится параллельно, поскольку чанки независимы.

\paragraph{Свойства стратегий}

Анализ, описанных выше стратегий, показывает, что они обладают свойством вложенности. Т.е., для того, что бы опровергнуть одну базовую подформулу (первая стратегия) необходимо найти ответы на вопросы (вторая стратегия). В свою очередь для поиска ответа, необходимо найти подстановки для каждого атома из конъюнкта вопроса (третья стратегия).

Исходя из этого, данные стратегии можно разместить по степени эффективности (иерархия стратегий). Не трудно видеть, что время, затрачиваемое на опровержение базы, как минимум, не меньше, чем время, затрачиваемое на поиск ответных подстановок, а на практике, как правило, оказывается намного больше (так как, как правило, для опровержения базы необходимо неоднократно ответить на некоторые вопросы). Аналогичные выводы делаются по отношению к другим стратегиям.

Кроме того, можно выделить единое для всех стратегий свойство – свойство однородности. Т.е. стратегии имеют единую структуру. А именно, все они, по сути, сводятся к применению некоторой операции (опровержение базы, поиск ответов и т.д.) для каждого элемента некоторого множества (базы, вопросы и т.д.).

Одной из рекомендаций при реализации описанных алгоритмов на кластерных вычислительных системах является правильное распределение задач между вычислительными узлами кластера, в зависимости от скорости коммуникации между ними. Например, программная реализация первой стратегии должна процесс привязывать к вычислительному узлу. Однако этого не стоит делать при реализации остальных стратегий, так как коммуникационные затраты, вполне вероятно, перекроют полезное время вычислений, и тем самым лишь ухудшат результат.

Отметим что данная стратегия в общем случае конфликтует со стратегией отсроченного присваивания (поскольку СОП может нарушать независимость баз и вопросов).

\paragraph{Тестирование}
Важным свойством параллельных схем алгоритмов является их масштабируемость, т.е. степень повышения эффективности с увеличением количества вычислительных элементов (ВЭ). Поэтому основной характеристикой является не конкретное время исполнения программ, а соотношение времени исполнения программы в параллельном режиме на заданном количестве ВЭ к времени исполнения этой же программы на одном ВЭ при различном количестве ВЭ.

Эксперименты проводились на задачах, формализация которых в языке ПО-формул обладает необходимыми свойствами для испытания параллельных стратегий, а именно: дизъюнктивное ветвление, большое количество вопросов, крупные конъюнкты вопроса.

Результаты находятся в соответствии с представленной иерархией стратегий. На рис. представлены результаты тестирования.

\begin{figure}[h]
	%\vspace{0.5cm}
	\centering
	\includegraphics[width=0.6\linewidth]{pics/Parallel.eps}
	\caption{Параллельные стратегии}
	\label{fig:parallel}
\end{figure}

Наибольшую эффективность, как и следовало ожидать, показала первая стратегия (естественно при наличии дизъюнктивного ветвления). Под эффективностью понимается уменьшение затрачиваемого времени с увеличением количества вычислительных узлов.


%============================= РАВЕНСТВА =========================
\subsection{Равенства}
Для работы с равенствами как правило очень неэффективно напрямую использовать аксиомы равенства (рефлексивность, симметричность, транзитивность, подстановочность). Например, если формула содержит лишь один бинарный функциональный символ $f$ и один бинарный атомарный символ $A$, то в языке ПОФ аксиомы равенства для такой формулы будут представлены следующим образом:
$$\left\lbrace
\begin{array}{l}
\forall x\colon\boldsymbol{True} - \exists\colon x = x \\
\forall x_1,y_1,x_2,_y2\colon x_1 = y_1, x_2 = y_2 - \exists\colon f(x_1,y_1) = f(x_2, y_2) \\
\forall x_1,y_1,x_2,_y2\colon x_1 = y_1, x_2 = y_2, A(x_1,y_1) - \exists\colon A(x_2,y_2)
\end{array}\right.
$$
Таким образом, для каждого функционального и атомарного символа из формулы ставится в соответствие подформула-вопрос аксиома равенства. Явное использование таких аксиом во-первых, усложняет структуру формулы (лишние вопросы), во-вторых, увеличивает число шагов вывода, в-третьих, генерирует много (потенциально бесконечно) фактов в базе, возможно ненужных, мешающих выводу.

Отметим что данная проблема не так ужасна как в МР, поскольку в МР могут генерироваться лишние дизъюнкты, а это соответствует генерированию лишних вопросов в ПОФ. В исчислении ПОФ же генерируются лишь атомы-факты, за которыми проще наблюдать, но тем не менее их много.

При классическом подходе, в соответствии с определением ~\ref{ircond} подстановка $\theta$ является ответом на вопрос, тогда и только тогда, когда $A \theta \subseteq B$ где $A$ - конъюнкт вопроса, а $B$ - конъюнкт базы. Поиск ответов есть задача поглощения, для решения которой как правило используется алгоритм матчинга, об этом уже писалось выше. В случае ПОФ используется основной матчинг, а в случае НЭЭ используется полуосновной-матчинг.

Для решения проблемы основного матчинга без явного использования аксиом равенства имеется задача основного матчинга с равенствами, которая формулируется следующим образом [microsoft]:
Для данного множества равенств $E(B)$, основного терма $t$ и терма $p$, который может содержать переменные, необходимо найти множество подстановок $\theta$, по модулю $E(B)$, такие что $E(B)\models t = p\theta$. Через $E(B)$ мы обозначим множество всех равенств в данной базе $B$. Две подстановки эквивалентны если их правые части попарно конгруэнты по модулю $E(B)$.

Для поиска таких ответов мы используем аппарат теории систем переписывания термов \cite{Nipkow}.



%=====================================================================
%==========================ХРАНИЛИЩЕ ОТВЕТОВ==========================
\subsection{Хранилище ответов}
Хранилище ответов предназначено для эффективной организации работы с ответными подстановками и синхронизации с бэктрэкингом.

Каждому атому конъюнкта вопроса соответствует чанк возможных подстановок, матчащих этот атом с атомами из базы. Использование чанков связано с тем что необходимо точно определять на каком шаге какие подстановки были найдены. Для поиска ответа на вопрос, необходимо учитывать совокупность чанков соответствующих всем атомам конъюнкта вопроса.

На рисунке представлена схема хранения подстановок.

\begin{figure}[h]
	%\vspace{0.5cm}
	\centering
	\includegraphics[width=0.6\linewidth]{pics/AnBase.eps}
	\caption{Подстановки}
	\label{fig:anbase}
\end{figure}

Далее из этой структуры выделяется ответ на вопрос. Для этого комбинируются подстановки из каждого чанка по одной. При этом подстановки должны быть совместимы. Две подстановки совместимы если их левые части равны, а правые унифицируемы. Например, если есть подстановки $\{x \rightarrow a\}$ и $\{x \rightarrow b\}$, где $b$ есть константа, то эти подстановки несовместимы, поскольку $a$ и $b$ неунифицируемы. А подстановки $\{x \rightarrow f(a)\}$ и $\{x \rightarrow f(h)\}$, где $h$ есть НЭЭ, совместимы, поскольку $f(a)$ и $f(h)$ унифицируемы с подстановкой $\{h \rightarrow a\}$. Результатом комбинации будет объединение всех совместимых и унифицирующих подстановок.

Перебор подстановок из чанков производится последовательно, это позволяет сохранить полноту.

%=================================================================================
%==================================СТАНДАРТНАЯ СТРАТЕГИЯ==========================
%=================================================================================
\subsection{Стандартная стратегия}
Главное свойство стандартной стратегии заключается в её полноте. Для полноты вывода необходимо организовать полный последовательный перебор всевозможных ответов на все вопросы. Для этого используются возможности дерева состояний вывода и хранилища ответов.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "dis"
%%% End:
