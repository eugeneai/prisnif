\chapter{Теоретический базис исследования}
\label{basis}

%===================================================================
\section{Автоматическое доказательство теорем}


%===================================================================
%===================================================================
\subsection{Исторические предпосылки к АДТ}
Пионерские идеи об автоматизации (механизации) рассуждений, скорее всего, высказали Раймунд Луллий (1235-1315) и позднее Готфрид Лейбниц (1646-1716) \cite{LogicComp}. Луллий описывал некую механическую машину для выведения новых истин, а Лейбниц предложил создать формальный универсальный язык ``lingua characteristica'', в котором можно было бы формулировать любые утверждения и создать для него исчисление ``calculus ratiocinator''. Так исчисление могло быть механизировано решать вопрос об истинности утверждений, и это бы стало ``освобождением человеческого разума от его собственных представлений о вещах''. В качестве примера Лейбниц рассматривал ситуацию, когда два участника спора, для проверки кто из них прав, переводят свои аргументы на ``lingua characteristica'' и потом говорят: ``Calculemus!'' --- подсчитаем. Хотя эти идеи так и остались идеями не найдя никакого материального воплощения, фактически Лейбницом были сформулированы две основных составляющих для автоматизации рассуждений: специальный язык для записи утверждений, который ныне называют ``формальным'' и правила оперирования выражениями этого языка --- ``правила вывода'', в совокупности составляющими формальную систему; наличие механизма способного работать с данным языком, в качестве которого сейчас выступает компьютер.

Первая составляющая развивалась в контексте математической логики и оснований математики. Тут стоит указать на роль работ следующих исследователей: Август де Морган, Джордж Буль, Чарльз Пирс, как основоположники логики высказывания и исследователи в области алгебры; Готтлоб Фреге \cite{Frege}, \cite{Sourcebook}, впервые описавший язык и исчисление предикатов (в несколько неестественной для современного человека форме); Джузеппе Пеано, Бертран Рассел, Давид Гильберт, развили результаты Фреге, и поставили важные задачи \cite{GilbertAkkerman}; Курт Гёдель, Алан Тьюринг, Алонзо Черч, получили результаты, касающиеся пределов возможностей формальных систем, в частности полнота \cite{Godel1} и неразрешимость теорий первого порядка, неполнота систем, выражающих арифметику; Альберт Туральф Сколем, показал что для данного множества истинных высказываний можно механически найти их доказательство; Жак Эрбран доказал, что для истинного математического предложения можно доказать что оно истинно и предложил метод доказательства. В совокупности с результатом Тьюринга и Черча это говорит о полуразрешимости теорий первого порядка. Идеи Эрбрана и по сей день лежат в основе многих методов.

Вторая составляющая развивалась в контексте вычислительных машин, основным толчком к созданию которых было в большей степени обусловлено выживанием в условиях второй мировой войны, можно отметить работы Джона фон Неймана, Норберта Винера, Алана Тьюринга, Конрада Цузе.

Развитие аппарата математической логики и вычислительных машин естественно привело к созданию первых работающих на практике систем АДТ: Программа М. Дэвиса в 1954 г. работающая на компьютере ``Johniac'', доказала что сумма двух четных чисел есть четное число (первое доказательство математического утверждения, произведенное на компьютере) \cite{LogicComp}; ``Логик-теоретик'', разработанный А. Невелом, Г. Саймоном, Дж. К. Шоу \cite{Newell1}, \cite{Newell2} в 1956 году для доказательства некоторых задач из Principia Mathematica \cite{PrinMat}, причем данная система была направлена на моделирование человеческих рассуждений; В 1958 г. Ван Хао создаёт систему, доказавшую 350 задач из ``Principia Mathematica'' \cite{WangHao}.


%===================================================================
%===================================================================
\subsection{Методы АДТ}
Дадим краткое описание наиболее популярных методов АДТ. Подробный анализ методов АДТ дан в \cite{HAR}.

Началом сильного развития области АДТ явился метод резолюций \cite{Robinson_1965} предложенный Дж.~Робинсоном в 1965 году (работы велись совместно с Л.~Уосом и Д.~Карсоном). Причиной его успеха явилась достаточно хорошая пригодность формализма для реализации на компьютере, в частности однородность представления данных. Для резолютивных методов требуется предобработка формул (предваренные нормальные формы, сколемизация), а вывод основан на приведении исходного выражения к противоречию, т.е. для установления факта общезначимости формулы, доказывается противоречивость её отрицания. Данный метод и по сей день занимает доминирующее положение среди теоретического базиса систем АДТ, предложено множество стратегий улучшения эффективности вывода и реализованы одни из самых сильнейших систем АДТ (в том числе для логик высшего порядка) \cite{otter, vprover, eprover, iprover, leoprover}. Более подробно о методе резолюций, его вариациях и стратегиях поиска ЛВ можно прочитать в \cite{HAR, ChenLi}.

Другим популярным направлением в развитии методов АДТ явился табличный метод \cite{tableau2} предложенный в 1955г. Е.В.~Бетом \cite{Beth1955} и позднее упрощенный Р. М. Смальяном \cite{Smullyan1995}. Для табличных методов не требуются специальные преобразования формул как для резолютивных методов, а доказательства строится как сведение задач к подзадачам.  Развитие данного подхода уходит корнями в секвенциальное исчисление Генцена без сечения \cite{gentzen1935} предложенное в 1935г, задолго до появления метода резолюций. На базе данного подхода разработаны некоторые достаточно сильные системы АДТ \cite{Isabelle, leancop}. Как правило, табличный метод применяется для неклассических логик.

Ещё одним направлением методов АДТ являются так называемые обратные методы \cite{inverse}, менее известные, чем резолютивные и табличные. Впервые, термин ``обратный метод'' был предложен Масловым~С.Ю. \cite{Maslov_1964} в 1964г, а предложенное исчисление было определено для первопорядковых логик без функциональных символов. Вывод строится в противовес табличному методу от подцелей к новым целям.


%===================================================================
%===================================================================
\subsection{Область применения систем АДТ}
Первоначально системы АДТ предназначались скорее для подтверждения возможности автоматизации рассуждений, а также для удовлетворения научного интереса авторов. Но почти полувековое развитие в данной области привело к тому что в 1994 году системой EQP была доказана открытая математическая проблема Роббинса \cite{McCuneRob}, которая формулируется следующим образом: ``Являются ли все алгебры Роббинса булевыми?''.

На сегодняшний день использование АДТ (с обоснованием его эффективности) замечено в следующих областях: верификация программ \cite{promsky,ATP_Ver2,keyproj}, синтез программ \cite{atpsoft, Butakov1}, верификация оборудования \cite{hardver,ACL2}, обработка естественных языков \cite{ATP_NLP}, исследование протоколов \cite{protolan}, исследование безопасности информационных потоков \cite{ATP_Flow}, удаление представлений в базах данных \cite{ATP_DB}, семантический веб \cite{semweb,tptp}, составление расписаний \cite{tptp}, задачи управления \cite{ICDS2000}, компьютерное зрение \cite{ATP_Vision}, математические проблемы \cite{tptp, McCuneRob}, решение проблем медицины \cite{med1, tptp},  и др.

Наибольшую популярность в настоящее время имеют следующие направления: верификация программных и аппаратных систем; синтез программного обеспечения; решение проблем математики (библиотека TPTP \cite{tptp}); логическое программирование; дедуктивные базы данных \cite{ontobox}.


%===================================================================
%===================================================================
\subsection{Классификация систем АДТ}

Мы классифицируем системы АДТ следующим образом:
\begin{enumerate}
\item Классические. Предназначены для доказательства теорем, формализованных языками первого порядка. Отличительной чертой является множество реализованных методик общего характера для повышения эффективности доказательства. Как правило, не предназначены для какой-либо специальной предметной области, и могут рассматриваться как универсальные. Наиболее известные из систем: Otter (больше не поддерживается) \cite{otter}, Vampire \cite{vprover}, EP \cite{eprover}, SPASS \cite{SPASS}, iProver \cite{iprover} и др.  В частности,  с помощью EQP \cite{EQP} была доказана открытая математическая проблема \cite{McCuneRob}, а Vampire уже много лет является победителем турнира среди систем АДТ \cite{CASC}. Кроме того, общей чертой данных систем, является использование лишь синтаксической информации о решаемой задаче, и минимальное взаимодействие с пользователем, т.е. развитие в направлении полной автоматизации решения задач.

\item Специализированные. Предназначены для заранее определенного класса задач и неклассических логик. Например, для различных алгебраических систем \cite{tptp}, геометрических задач \cite{ATP_geometry, tptp} и др. Характерны тем, что либо в принципе предназначены только для указанного класса, либо показывают хорошую эффективность только на задачах заданного класса, но при этом могут быть использованы и для решения других задач. Кроме того, к этому классу могут быть причислены системы АДТ для логик высшего порядка \cite{HOLprover} или, например, для модальных логик \cite{ModalProver}.

\item Настраиваемые (полиморфные). Отчасти к таким системам можно отнести и системы из предыдущих классов, однако под настраиванием мы понимаем в большей степени настройку в соответствии с содержательной информацией о задаче. Как правило, такие системы представляют собой комбинацию существующих систем, например Isabelle \cite{Isabelle} или система, предложенная в \cite{ProblemOrientedATP1}. Coq \cite{LaCoq} предлагает использование так называемых ``тактик'', соединение нескольких типовых шагов вывода в один шаг. Интерактивные системы, хотя и не могут в полной мере быть автоматическими, всё же они интересны тем, что используют философию тесного взаимодействия человека и компьютера.
\end{enumerate}


%===================================================================

%===================================================================
%===================================================================
\section[Язык и исчисление позитивно-образованных формул]{Язык и исчисление позитивно-образованных\\ формул}

В основе разрабатываемой системы лежит исчисление ПО--формул \cite{ICDS2000, DavydovX, SNV1990, mais}.

%Исчисление ПО--формул $\boldsymbol{JF}$ есть тройка $\left\langle \boldsymbol{LF}, Ax\boldsymbol{JF}, \bomega \right\rangle$, где $\boldsymbol{LF}$ --- язык ПО--формул, $Ax\boldsymbol{JF}$ --- единственная схема аксиом и $\bomega$ --- единственное правило вывода $\boldsymbol{JF}.$

\subsection{Предварительные сведения и используемые сокращения}
Будем рассматривать классический язык первопорядковой логики предикатов (ЛП) состоящий из формул, построенных над атомарными формулами с помощью логических связок $\&, \vee, \neg, \rightarrow, \leftrightarrow$, кванторов $\forall$ и $\exists$, констант $true$ и $false$.

%2. Используемые сокращения
Пусть $X = \{x_1,\ldots,x_k\}$ --- множество переменных, $A = \{A_1,\ldots,A_m\}$ --- атомарные формулы, и $F = \{F_1,\ldots,F_n\}$ --- произвольные формулы. Тогда формулы следующего вида $((\forall x_1) \ldots (\forall x_k) (A_1 \& \ldots \& A_m \rightarrow (F_1 \vee \ldots \vee F_n)))$ и $((\exists x_1) \ldots (\exists x_k) (A_1 \& \ldots \& A_m \& (F_1 \& \ldots \& F_n)))$ будем обозначать как $\forall_XA\colon F$ и $\exists_XA\colon F$, имя ввиду что $\forall$--квантор соответствует $\rightarrow F$, где $F$ понимается как дизъюнкция всех формул из $F$, а $\exists$--квантор соответствует $\& F$, где $F$ понимается как конъюнкция всех формул из $F$.

Если $F = \emptyset$ формулы имеют вид $\forall_XA\colon\emptyset \equiv \forall_XA \rightarrow false$ и $\exists_XA\colon\emptyset \equiv \exists_XA \& true$, поскольку пустой дизъюнкт тождественен $false$, а пустой конъюнкт $true$. Сокращенно будем записывать такие формулы как $\forall_XA$ и $\exists_XA$.

Если $X = \emptyset$, то пишем $\forall A\colon F$ и $\exists A\colon F$.

%Множество атомов $A$ будем называть {\em конъюнктом}, и если $A = \emptyset$, то будем обозначать его как $true$.

Переменные из $X$ связаны соответствующими кванторами и называются $\forall$--переменные и $\exists$--переменные, соответственно, $\forall$-переменная которая не встречается в соответствующем конъюнкте называется {\em неограниченной} переменной. Множество атомов $A$ будем называть {\em конъюнктом}. Как уже упоминалось выше, пустой конъюнкт тождественен $true$.

В связи с изложенными сокращениями отметим следующий факт: $\forall \emptyset \equiv \forall \emptyset:\emptyset \equiv \forall true \rightarrow false \equiv false$

Конструкции $\forall_XA$ и $\exists_XA$ называются позитивными типовыми кванторами (ТК), поскольку $A$ это конъюнкция только позитивных литер понимаемая как типовое условие для $X$. На практике, данные конструкции обозначают следующие фразы: ``для всех $X$ удовлетворяющих $A$ справедливо...'' или ``существует $X$ удовлетворяющий $A$ такой что...''. Например, ``для любых целых чисел $x,y,z$ и $n>2$ справедливо $x^n + y^n \ne z^n$''.

Первоначально, термин ``типовый квантор'' был введен Н. Бурбаки \cite{Bourbaki} как часть нотации для формализации математики. Но типовые кванторы пригодны и для формализации других прикладных областей.



%---------------------ЯЗЫК ПО-ФОРМУЛ--------------------
\subsection{Язык позитивно--образованных формул}


\begin{definition}[Позитивно--образованные формулы (ПОФ)]
\label{def:pcf}
Пусть, $X$ --- множество переменных, и $A$ --- конъюнкт.
\begin{enumerate}

\item $\exists_XA$ и $\forall_XA$ есть $\exists$--ПОФ и $\forall$--ПОФ соответственно.

\item Если $F = \{F_1,\ldots,F_n\}$ есть $\forall$--ПОФы, тогда $\exists_XA\colon F$ есть $\exists$--ПОФ.

\item Если $F = \{F_1,\ldots,F_n\}$ есть $\exists$--ПОФы, тогда $\forall_XA\colon F$ есть $\forall$--ПОФ.

\item Любая $\exists$--ПОФ или $\forall$--ПОФ есть ПОФ.
\end{enumerate}
\end{definition}

Данный вид формул называется позитивно-образованным, поскольку для их записи используются только позитивные типовые кванторы. Иными словами, формула не содержит оператора отрицания.

Любая формула языка предикатов первого порядка может быть представлена как позитивно--образованная формула \cite{ICDS2000}. Таким образом ПО--формула есть особый вид записи классических формул языка предикатов, подобно КНФ, ДНФ и др.

ПО--формула начинающаяся с $\forall \emptyset$ называется ПО--формулой в {\em каноническом виде}.

%In the sequel, only PCFs in the canonical form are considered. %если не оговорено обратного.

Очевидно, что любая ПОФ может быть приведена к каноническому виду. Действительно, допустим $F$ --- это $\exists$--ПОФ, тогда выражние вида
$\forall \emptyset\colon F$ по определению является $\forall$--ПОФ, и соответствует записи $true \rightarrow F$ тождественной $F$. Если $F$ --- это неканоническая $\forall$--ПОФ, тогда $\forall \emptyset\colon\{\exists \emptyset\colon F\}$ соответствует записи $true \rightarrow \{true\&F\}$, тождественной $F$. Типовые кванторы $\forall \emptyset$ и $\exists \emptyset$ называются {\em фиктивными}, поскольку не влияют на истинность формулы и не связывают никаких переменных, а только лишь служат конструкциями сохраняющими корректную запись ПОФ.

Для удобства читаемости формул, будем представлять их в древовидной форме следующим образом:
$$Q_XA\colon\{F_1,\ldots,F_n\} \equiv Q_XA \left\{
\begin{array}{lcl}
 F_1 \\
 \ldots \\
 F_n
\end{array}
\right.,$$

\noindent{}где $Q$ некоторый квантор, и пользоваться соответствующей терминологией: узел, корень, лист, ветвь и т.д. Учитывая что квантору $\forall$ соответствует дизъюнкция формул $\{F_1,\ldots,F_n\}$, а квантору $\exists$ соответствует конъюнкция, то будем говорить что $\forall$ узлу соответствует {\em дизъюнктивное ветвление}, а $\exists$ узлу {\em конъюнктивное}.

Некоторые части канонической ПО--формулы имееют специальные названия:
\begin{enumerate}
\item Корневой узел имеет вид $\forall \emptyset$ и назвается {\em корень ПО--формулы};

\item Дочерние узлы корня ПО--формулы имеют вид $\exists_XA$ и называются {\em базами ПО--формулы}, конъюнкт $A$ называется {\em базой фактов}, а вся подформула начинающаяся с базового узла называется {\em базовой подформулой};

\item Дочерние узлы баз имею вид $\forall_YB$ и называются {\em вопросами} к родительской базе. Если вопрос является листовым узлом $\forall_YB \equiv \forall_YB\colon false$, то он называется {\em целевым вопросом}. %Иногда, для того чтоб подчеркнуть тот факт что вопрос является целевым, будем в явной форме записывать конcтанту $false$.

\item Поддеревья вопросов называются {\em консеквентами} или {\em следствиями}. Следствием целевого вопроса является $false$.

\end{enumerate}


Для того чтоб читателю было удобнее ориентироваться в записях ПО--формул и понять смысл терминологии, проведем аналогию с языком Пролога. Данная аналогия не является формальной, а приводится лишь для прояснения.

\begin{enumerate}
\item База фактов ПОФ, являющаяся конъюнкцией атомов, соответствует множеству фактов пролога.
\item Правила пролога имеют форму \texttt{P0:- P1,..., Pn}. В данном случае, \texttt{P1,...,Pn} соответствует конъюнкту вопроса, а \texttt{P0} его консеквенту (следствию). Отметим, что язык ПО--формул несколько богаче чем язык пролога, поскольку допускает использование в качестве консеквента дизъюнкцию произвольных формул, пролог же допускает лишь одну атомарную формулу.
\item Целевой вопрос ПО--формулы вида $\forall_YB$ соответствует запросу пролога.
\end{enumerate}

%-----------
\begin{example}

Рассмотрим следующую программу на языке Пролог и запрос к ней:
\texttt{\raggedright\noindent
\\
in(a,b).\\
in(b,c).\\
it(X,Y):-in(X,Z),in(Z,Y).\\
?- it(a,X).\\
}

Соответствующая данной программе ПО--формула:

$\forall \emptyset\colon\exists in(a,b),in(b,c)\colon\left\{
\begin{array}{lcl}
 \forall_{x,y,z}in(x,z),in(z,y)\colon\exists it(x,y) \\
 \forall_x it(a,X)
\end{array}
\right..$
\end{example}

%---------
\begin{example}
Приведем пример другой ПО--формулы.

$\forall$

Данная формула принципиально невыразима на Прологовском языке дизъюнктов Хорна. Кроме того в данной формуле используются $\exists$--переменные и сложные формы консеквентов, что отличает язык ПО--формул от произвольного языка дизъюнктов, используемого в методе резолюций и требущего процедуру сколемизации (убирания $\exists$--переменных).
\end{example}

Более подробно об основных разлиячах с языками дизъюнктов будет сказано позднее.

%========================================================





%============================================================
%Будем обозначать множество всех конъюнктов как $Con$ и положим что {\em конъюнкт} либо конечное множестве обычных атомов языка предикатов первого порядка либо $\boldsymbol{False}$, где $\boldsymbol{False}$ удовлетворяет условию $A \subset \boldsymbol{False} $ для любого $A \in Con$. Пустой конъюнкт обозначается как $\boldsymbol{True}$. Очевидно что если $A \in Con$ тогда $A \cup \boldsymbol{False} = \boldsymbol{False}$. Атомы любого конъюнкта, исключая $\boldsymbol{True}$ и $\boldsymbol{False}$, могут содержать переменные, константные и функциональные символы.

%\begin{definition}\label{def:1}
%Пусть $\bar{x}$ есть множество переменных и $A$ есть конъюнкт. Правильно построенные формулы языка ПОФ определяются следующим образом:

%Выражение вида $\exists \bar{x}\colon A$ есть $\exists$--формула; выражение вида $\forall \bar{x}\colon A$ есть $\forall$--формула.

%Пусть $G_1,\ldots,G_k$ являются $\exists$--формулами, тогда $\forall$--формула имеет следующий вид: $\forall \bar{x}\colon A\left(G_1,\ldots,G_k\right)$.

%Пусть $G_1,\ldots,G_k$ являются $\forall$--формулами, тогда $\exists$--формула имеет следующий вид: $\exists \bar{x}\colon A\left(G_1,\ldots,G_k\right)$.

%\end{definition}

%Выражение является правильно построенной ПО--формулой если оно построено только по правилам Определения \ref{def:1}.


%semantic
%Теперь определим семантику ПО--формул как семантику соответствующих формул языка предикатов первого порядка.

%\begin{definition}\label{def:semantic}
%Пусть $A = \{A_1,\ldots,A_l\}$ есть конъюнкт и $\bar{x} = \{x_1,\ldots,x_n\}$ --- множество переменных. Через $A^{\&}$ обозначим $A_1 \&\ldots\&A_l$, при этом $\boldsymbol{False}^{\&}= False, \boldsymbol{True}^{\&}=True$ (пропозициональные константы). Через $F^{\text{\tiny{FOF}}}$ обозначим образ соответствующей ПО--формулы $F$ в языке FOL.

%Если $F= \exists \bar{x}\colon A$ то $F^{\text{\tiny{FOF}}} = \exists x_1 \ldots \exists x_n \left(A^{\&}\right).$

%Если $F = \forall \bar{x}\colon A$ то $F^{\text{\tiny{FOF}}} = \forall x_1 \ldots \forall x_n \left(A^{\&}\right).$

%Если $F = \exists \bar{x}\colon A\left(G_1,\ldots,G_k\right)$ то \goodbreak \hspace{5cm}$F^{\text{\tiny{FOF}}} = \exists x_1 \ldots \exists x_n  \left(A^{\&} \& \left(G_{1}^{\text{\tiny{FOF}}} \& \ldots \& G_{k}^{\text{\tiny{FOF}}}\right)\right).$

%Если $F = \forall \bar{x}\colon A\left(G_1,\ldots,G_k\right)$ то \goodbreak \hspace{5cm}$F^{\text{\tiny{FOF}}} = \forall x_1 \ldots \forall x_n \left(A^{\&}\rightarrow \left(G_{1}^{\text{\tiny{FOF}}} \vee\ldots\vee G_{k}^{\text{\tiny{FOF}}}\right)\right).$

%\end{definition}

%Любая ПО--формула очевидно имеет структуру дерева. Таким образом, для удобства читаемости мы будем представлять их как древовидные структуры, а также пользоваться соответствующей терминологией: узел, корень, ветвь, лист и т.д.

%Если ПО--формула $F$ начинается с $\forall\colon\boldsymbol{True}$ узла, и каждый лист $F$ является $\exists$--узлом, то $F$ называется ПО--формулой в {\em канонической форме}.


%В дальнейшем, если не оговорено обратного, будем рассматривать только ПОФы в каноническом виде.

%Некоторые части ПО--формул имеют специальные названия: корневой (0-глубины) узел называется {\em корнем} ПО--формулы; любой узел глубины 1 называется {\em базой} ПО--формулы; максимальное поддерево начинающееся с узла глубины 1 называется {\em базовой подформулой}; любой узел глубины 2 называется {\em вопросом} к базе; максимальное поддерево начинающееся с узла глубины 2 называется {\em подформулой--вопросом}; максимальное поддерево начинающееся с узла глубины 3 называется {\em консеквентом}. В соответствии с определением семантики если узел чётной (нечетной) глубины имеет более чем одного потомка, то будем говорить, что этот узел имеет {\em дизъюнктивное ветвление} (соответственно {\em конъюнктивное ветвление}). Формулы гллубиной более 3 будем называть {\em глубокими}.

%\begin{example}
%Рассмотрим формулу языка логики предикатов 1-ого порядка
%$$F= \neg\bigl(\forall x\:\exists y P(x,y)\rightarrow \exists z P(z,z)\bigr).$$
%Образ $F^{\text{\tiny{PCF}}}$ формулы $F$ в языке ПО--формул есть
%$$F^{\text{\tiny{PCF}}} = \forall\colon \boldsymbol{True}-\exists\colon\boldsymbol{True} \left\{
%\begin{array}{lcl}
% \forall x\colon\boldsymbol{True} & - & \exists y\colon P(x,y) \\
% \forall z\colon P(z,z) & - & \exists\colon\boldsymbol{False}
%\end{array}
%\right..$$

%\end{example}


%-------------------------ИСЧИСЛЕНИЕ ПО-ФОРМУЛ-------------------
\subsection{Исчисление позитивно--образованных формул}
Логическое исчисление состоит из трёх компонент: язык, аксиомы и правила вывода. Язык ПО--формул описан в предыдущем разделе. Теперь опишем аксиомы и правила вывода.

Исчисление ПО--формул имеет единственную аксиому и единственное правило вывода.

Как и в методе резолюций, для доказательства формулы $F$ мы будем пытаться опровергнуть её отрицание, поэтому аксиома исчисления ПО--формул --- тождественно ложная ПО--формула вида $\forall \emptyset$ (согласно принятым раннее сокращениям). %Выражение $\forall true$ действительно является ложным, поскольку в соответствии с принятыми сокращениями тождественно выражению $\forall true:false$, которое в свою очередь тождественно выражению $true \rightarrow false \equiv false$.

\begin{definition}[Ответ]
\label{ircond}
Будем говорить что вопрос $\forall_YB\colon\Upsilon$ к базе $\exists_XA$ имеет {\em ответ} $\theta$ тогда и только тогда когда $\theta$ есть подстановка $Y \rightarrow H^{\infty} \cup X$ и $B\theta \subseteq A$, где $H^{\infty}$ есть Эрбранов универс, основанный на константах и функциональных символах из соответствующей базовой подформулы.
\end{definition}

\begin{definition}[Операция расщепления split]
\label{splitting}
Пусть $F = \exists_XA\colon\Psi$, и $S = \forall_YB\colon\Upsilon$, где $\Upsilon = \{\exists_{Z_1}C_1\colon\Gamma_1,\ldots,\exists_{Z_n}C_n\colon\Gamma_n\}$ тогда $split(F,S) = \{\exists_{X \cup {Z_1}'} A \cup {C_1}'\colon\Psi \cup {\Gamma_1}',\ldots,\exists_{X \cup {Z_n}'} A \cup {C_n}'\colon\Psi \cup {\Gamma_n}'\}$, где $'$ есть оператор переименования переменных. И мы говорим что формула $F$ расщеплена формулой $S$. Очевидно, $split(F,\forall_YB) = split(F,\forall_YB\colon\emptyset) = \emptyset$.
\end{definition}

%omega inference rule
\begin{definition}[Правило вывода $\omega$]\label{omega}
\label{omegarul}
Рассмотрим некоторую ПОФ, находящуюся в каноническом виде $F = \forall true\colon\Phi$. Пусть существует вопрос $Q$ который имеет ответ $\theta$ к соответствующей базе $S \in \Phi$, тогда $\omega F  = \forall true:\Phi \setminus \{S\} \cup split(S,Q\theta)$.
\end{definition}

Иными словами, если вопрос имеет ответ к своей базе, тогда базовая подформула расщепляется этим вопросом. В случае целевого вопроса, мы говорим что базовая подформула опровергнута, поскольку
$split(S,\forall_YB) = \emptyset$. Опровергнутая базовая подформула $S$ удаляется из множества баз $\Phi$, поскольку $\Phi \setminus \{S\} \cup \emptyset = \Phi \setminus \{S\}$.

После того как опровергнуты все базовые подформулы, формула $F$ также опровергается, поскольку $\forall \emptyset\colon\emptyset = \forall \emptyset$, а это тождественно ложная аксиома.

Отметим, что ответ на вопрос с дизъюнктивным ветвлением приводит к увеличению количества базовых подформул в силу использования оператора расщепления.

%For this reason we can say that $\forall[\emptyset,\emptyset]$ is a single axiom in the method of PCF refutation.


%Thus, for proof that some FOF $F$ is a theorem in FOL, we represent  negation of $F$ as PCF, and then applying inference rule $\omega$ until we obtain the $\forall[\emptyset,\emptyset]$.



%Схема аксиом исчисления ПО--формул $\boldsymbol{JF}$ имеет следующую форму:
%$$ Ax\boldsymbol{JF} = \forall\colon\boldsymbol{True}\left(\exists \bar{x}_1\colon\boldsymbol{False}\left(\widetilde{\Phi}_1\right),\ldots,\exists \bar{x}_n\colon\boldsymbol{False}\left(\widetilde{\Phi}_n\right)\right). $$

%В исчислении ПО--формул для того, чтобы доказать $F$ мы будем пытаться опровергнуть её отрицание, поэтому аксиома исчисления ПО--формул ---  тождественно ложное высказывание. Таким образом процесс вывода в исчислении ПО--формул является процессом {\em опровержения}.

%\begin{definition}
%\label{ircond}
%Будем говорить что вопрос $\forall \bar{y}\colon A$ к базе $\exists \bar{x}\colon B$ имеет {\em ответ} $\theta$  тогда и только тогда, когда $\theta$ есть подстановка $\bar{y} \rightarrow H^{\infty}$ и $A\theta \subseteq B$, где $H^{\infty}$ есть эрбранов универсум, основанный на $\exists$--переменных из $\bar{x}$, константных и функциональных символах которые встречаются в соответствующей базе. Ответ $\theta$, будем иногда называть {\em ответной подстановкой}.
%\end{definition}

%The unique unary inference rule $\bomega$ is defined as follows.

%\begin{definition}
%\label{omega}
%Если $F$ имеет структуру $\forall\colon\boldsymbol{True}\left(\exists \bar{x}\colon B\left(\Phi\right),\Sigma\right)$, где $\Sigma$ есть список других базовых подформул, и $\Phi$ есть список подформул--вопросов содержащий подформулу--вопрос $\forall \bar{y}\colon A(\exists \bar{z}_i\colon C_i\left(\Psi_i\right))_{i=\overline{1,k}}$, тогда заключение $\bomega F$ есть результат применения унарного правила вывода $\bomega$ к вопросу $\forall \bar{y}\colon A$ с ответом $\theta$, и $\bomega F = \forall\colon\boldsymbol{True}(\exists \bar{x} \cup \bar{z}_i\colon B \cup C_i\theta\left(\Phi \cup \Psi_i\theta\right)_{i=\overline{1,k}},\Sigma).$

%\end{definition}

%После соответствующего переименования некоторых переменных в каждой подформуле, выражение $\bomega F$ будет удовлетворять всем условиям пра\-виль\-но--построенных ПО--формул.

%
%Любая конечная последовательность ПО--формул $F, \bomega F, \bomega^2 F,\ldots,$ $\bomega^n F$, где $\bomega^n F \in Ax\boldsymbol{JF}$ называется {\em опровержением} $F$ в исчислении ПО--формул. Иногда будем использовать слово вывод вместо cслова опровержение.

%Вопрос с консеквентом $\exists:\boldsymbol{False}$ называется {\em целевым вопросом}. Если вопрос имеет дизъюнктивное ветвление, то ответ на этот вопрос приводит к расщеплению соответствующей базовой подформулы на несколько новых.

Рассмотрим пример.

\begin{example}[Опровержение ПО--формулы]\label{proofexample}


\begin{equation*}\label{ex:f1}
	F_1 = \forall \emptyset\colon \exists S(e)
	\left\lbrace
	\begin{array}{l}
		Q_1 \\
		Q_2 \\
		Q_3 \\
		Q_4
	\end{array}\right..
\end{equation*}

\begin{equation*}
	\begin{array}{l}
	Q_1 = \forall_x S(x)\colon \exists A(a) \\
	Q_2 = \forall_{x,y} C(x),D(y) \\
	Q_3 = \forall_{x,y} B(x),C(f(y)) \\
	Q_4 =
	\forall_x A(x)
	\left\lbrace
	\begin{array}{l}
		\exists_y B(y),C(f(x)) \\
		\exists C(x): \forall_z A(z),C(z)\colon \exists D(f(z))
	\end{array}\right.
	\end{array}
\end{equation*}

База формулы состоит из одного факта $S(e)$. К данной базе имеется 4 вопроса $Q_1,\ldots,Q_4$. Вопросы $Q_2$ и $Q_3$ являются целевыми. Вопрос $Q_4$ имеет дизъюнктивное ветвление (т.е. является нехорновским - невыразимым в языке пролога).

На первом шаге вывода существует только один ответ $\{x \rightarrow e\}$ на вопрос $Q_1$. После применения $\bomega$ с этим ответом, формула приобретает следующий вид:
\begin{equation*}\label{ex:f2}
	F_2 = \forall \emptyset\colon \exists S(e),A(a)
	\left\lbrace
	\begin{array}{l}
		Q_1 \\
		Q_2 \\
		Q_3 \\
		Q_4
	\end{array}\right..
\end{equation*}
На втором шаге вывода существует только один ответ $\{x \rightarrow a\}$ на вопрос $Q_4$. После применения $\bomega$ с этим ответом, формула расщепляется, потому что $Q_4$ имеет дизъюнктивное ветвление. И теперь формула имеет следующий вид:

\begin{equation*}\label{ex:f3}
F_3 =
\forall\emptyset\colon
\left\lbrace
\begin{array}{l}
	\exists_{y_1} S(e),A(a),B(y_1),C(f(a))
	\left\lbrace
	\begin{array}{l}
		Q_1 \\ \cdots \\ Q_4
	\end{array}\right. \\
	\exists S(e)A(a),C(a)
	\left\lbrace
	\begin{array}{l}
		Q_1 \\ \cdots \\ Q_4 \\
		\forall_z A(z),C(z)\colon \exists D(f(z))
	\end{array}\right. \\
\end{array}\right..
\end{equation*}

На третьем шаге вывода первая база может быть опровергнута ответом $\{x \rightarrow y_1; y \rightarrow a\}$ на целевой вопрос $Q_3$. Опровергнутая база (подформула) для удобства представления может быть удалена из списка базовых подформул.

На четвертом шаге вывода существует ответ $\{z \rightarrow a\}$ на пятый новый вопрос. И формула приобретает следующий вид:
\begin{equation*}\label{ex:f5}
	F_4 = \forall\emptyset\colon \exists S(e),A(a), C(a),D(f(a))
	\left\lbrace
	\begin{array}{l}
		Q_1 \\ \cdots \\ Q_4 \\
		\forall_z A(z),C(z)\colon \exists D(f(z))
	\end{array}\right..
\end{equation*}

На пятом шаге вывода единственная база может быть опровергнута ответом $\{x \rightarrow a; y \rightarrow f(a)\}$ на целевой вопрос $Q_4$.

Опровержение закончено поскольку все базы опровергнуты.

\end{example}

Для данного исчисления доказаны его корректность и полнота \cite{ICDS2000, DavydovX}. Кроме того, авторами перечисленных работ выделены основные особенности, которые предположительно должны влиять на повышение эффективности поиска ЛВ.

%----------------------------------ОСОБЕННОСТИ ПО-ФОРМУЛ--------------------
\subsection{Свойства ПО--формул}
%Основные свойства ПО--формул описаны в \cite{ICDS2000, mais}.
%В литературе выделяются различные положительные стороны исчисления ПО--формул. Выделим те, которые, на наш взгляд, являются наиболее подходящими для задачи построения системы АДТ.

\begin{enumerate}
\item\label{flbs} Любая ПО--формула имеет {\em крупноблочную структуру} и только {\em позитивные кванторы} $\exists$ и $\forall$.
%
\item\label{fsimple} Хотя ПО--формулы содержат как квантор $\exists$ так и квантор $\forall$, структура же ПО--формул {\em простая}, {\em регулярная} и {\em предсказуемая} благодаря регулярному чередованию кванторов $\exists$ и $\forall$ по всем ветвям формулы.
%
\item Нет необходимости в предварительной обработке первоначальной формулы первого порядка с помощью процедуры сколемизации (удаление переменных, связанных кванторами существования). Процедура сколемизации приводит к увеличению сложности термов, а значит и всей формулы. Кроме того, данная особенность делает исчисление более человеко--ориентированным.
%
\item ``Теоретические'' кванторы $\forall x$ и $\exists x$ обычно не используются в формализации человеческих знаний, вместо этого чаще используются типовые кванторы $\forall_x A \rightarrow \sqcup$ и $\exists_x A \& \sqcup$ \cite{Bourbaki, ICDS2000, NNN}.
%
\item\label{frule} Исчисление ПО--формул содержит только одно правило вывода и это свойство (как и в случае метода резолюций) делает исчисление более машинно--ориентированным. Кроме того, правило вывода является крупноблочным, что сокращает количество шагов вывода, и делает вывод более понятным для человека.
%
\item\label{froot} Процедура ЛВ фокусируется в ближайшей окрестности корня ПО--фор\-му\-лы, благодаря особенностям \ref{flbs}, \ref{fsimple}.
%
\item\label{fqa} ЛВ может быть представлен в терминах {\em вопросно--ответной} процедуры \cite{ICDS2000}, а не в технических терминах формального вывода (в терминах логических связок, атомов и др.). Базовый конъюнкт может быть интерпретирован как {\em база фактов}.
%
\item Имеется естественный {\em ИЛИ--параллелизм}.
%
\item\label{fheu} Благодаря \ref{flbs}, \ref{fsimple}, \ref{froot}, \ref{fqa} процедура ЛВ {\em хорошо совместима с конкретными эвристиками приложения}, а также с эвристиками общего управления выводом. Благодаря \ref{frule} доказательство состоит из крупноблочных шагов, и оно хорошо {\em наблюдаемо} и {\em управляемо}.
%
\item Благодаря \ref{fqa}, \ref{fheu} доказательство может быть интерпретировано человеком.
%
\item Семантика исчисления ПО--формул может быть изменена без какой либо модификации системы аксиом или правила вывода $\bomega$. Такая модификация реализуется при помощи только ограничений на применение правила вывода $\bomega$ и позволяет трансформировать классическую семантику исчисления ПО--формул в немонотонную, интуиционистскую и т.п. Примеры использования таких семантик представлены в \cite{ICDS2000}.
\end{enumerate}

%===================================================================
\subsection{Существующие системы АДТ}
%Итак, Исчисление ПО--формул, взятое за базис разработанной системы АДТ, является логическим формализмом первого порядка. Доказательство теорем в исчислении ПО--формул основано на процедуре приведения к противоречию отрицания исходной формулы. Поэтому, далее говоря о доказательстве теорем, будем иметь ввиду опровержение их в исчислении ПО--формул.


Из существующих систем АДТ для исчисления ПО--формул, выделим ряд версий системы КВАНТ \cite{dissChe, Che2, QUANT4}, разработанных раннее Е.А.~Черкашиным и его учениками, система М.И. Бутакова предназначенная для решения задач разбора LL-1--грамматик \cite{Butakov1}. Система М.И. Бутакова конкретно предназначена для синтеза разборщика. Система Черкашина была разработана без учета функциональных символов, неограниченных переменных, работы с предикатом равенства, параллельных схем алгоритмов, стратегий экономии памяти и др. В ИДСТУ СО РАН реализованы еще две версии --- Е.Сомова, ориентированная на управление техническими системами, она, фактически, поддерживала очень узкий подкласс ПО--формул и версия Ш.Б.~Гулямова \cite{Gulamov}.

Данные системы относятся ко второму классу систем АДТ, согласно классификации изложенной выше. То есть, являются специализированными, и не предназначены для решения задач широкого класса.


%Авторами самых передовых пруверов неоднократно высказывалось что сложность разработки начинает достигать своего предела. Внедряемые методики крайне сложны в реализации, в совмещении с другими методиками, портят расширяемость систему, и вносят абсолютное запутывание в то что происходит внутри системы во время работы. Так, например, в работе \cite{BTPStickel}, автор М.~Стикель (M. Stickel) приводит главу с названием в переводе на русский язык <<Индексирование --- необходимое зло>>, при этом сам М.~Стикель является автором одной из очень популярной и применяемой в самых передовых пруверах методики индексирования путями (path indexing) \cite{pathindex}.

%В работах \cite{Eprover} указывается на то что их система более интеллектна по сравнению с другими системами. Такая интеллектность обусловлена возможностью более гибкого подключения дополнительных эвристик для решения задач определенного класса.

%Отсюда можно сказать что, в целом, действительно в области АДТ есть необходимость в новых методах либо в развитии старых в том направлении, чтобы привлекать возможности человека а так же гибкости системы для варьирования своего поведения в зависимости от решаемой задачи.



%О современных системах сказано ниже.

%На сегодняшний день доминирующее положение занимают подходы, в основе которых лежит язык представления формул в виде конъюнктивной нормальной формы (КНФ): метод резолюций и его модификации, парамодуляция, исчисление суперпозиций, исчисления примеров (instantion calculus) \cite{korovin9}, табличные методы \cite{tableau2}.


%Взятые за базис данной работы первопорядковый язык и исчисление позитивно--образованных формул (ПО--формул) \cite{ICDS2000, Vas1995} разработаны академиком Васильевым~С.Н., к.ф-м.н. Жерловым~А.К. и академиком Матросовым~В.М. на основе языка типово-кванторных формул, изначально использовавшегося для формализации свойств динамических систем и синтеза теорем в методе векторных функций Ляпунова.

%Верификация программного и аппаратного обеспечения, логические и constraint-языки программирования... Приложения АДТ, в т.ч. для логико--динамических систем (Васильев). Или это все дальше есть?

%Отметим что уже в то время указывалось на важность применения эвристик \cite{LogicComp}. И уже тогда зародилась некоторая конкуренция между чисто машинными подходами и эвристическими. В 1960-ые Л.М.~Нортон разработал эвристическую систему АДТ для теории групп \cite{LogicComp}.


%=================================================================================
%=================================================================================
\section{Основные направления повышения эффективности поиска ЛВ}
%\section{Свойства формализма ПО--формул, влияющие на эффективность поиска ЛВ}
Для того, чтобы алгоритмы адекватно использовали возможности ПО--формализма необходимо выявить его совместимые полезные свойства, а также свойства, не совместимые с адаптируемыми алгоритмами.  Положительные особенности, которые обеспечены алгоритмически в рамках данной диссертации, представлены выше.

Теперь опишем особенности данного формализма, которые необходимо разрешить, для эффективной реализации системы АДТ.
Анализ исчисления ПО--формул показал три основные проблемы (с указанием влияния на критерии эффективности, изложенные во введении):
\begin{enumerate}
\item {Поиск ответов на вопросы с неограниченными переменными.} Данная процедура требует выбора подставляемого терма для переменной вопроса из эрбранова универсума, который, в общем случае, т.е. при наличии функциональных символов, является счетным (бесконечным) множеством. Изначально неизвестно, какой именно терм необходимо выбрать, причём формально любая подстановка является корректной, хотя и не обязательно приводящей в итоге к опровержению формулы. В данном случае, решение проблемы направлено на повышение эффективности согласно критериям 1,2.

%Сделаем несколько замечаний. Во-первых, при решении прикладных задач, переменные связанные квантором всеобщности ограничиваются типовым условием, а значит появление открытых переменных в данном случае следует рассматривать как аномалию в следствии некачественной или даже некорректной формализации задачи. Это, как правило, значит, что решение данной проблемы лежит вне прикладной области, оно необходимо для решения общематематических теорем, например, из библиотеки TPTP.  Во--вторых, отказаться от использования функциональных символов (как это скромно сделано в \cite{ICDS2000}), но наличие функциональных символов есть основа сложных задач. Анализ решаемых задач показывает что как правило в прикладных задачах нет нужды использовать неограниченные переменные, т.к. в их формальном представлении их нет. В общих же задачах сложнее найти какие-то особенности, которые применяются другими стратегиями, а значит конфликт частично разрешается просто разграничением областей применения системы.

\item Язык ПО--формул в \cite{ICDS2000} характеризуется как ``достаточно   однородный, но в то же время хорошо структурированный'', а соответствующее исчисление  ``хорошо усваивает эвристики'', т.е. базовая стратегия исчисления достаточно легко настраивается под конкретную задачу. Стоит заметить, что представление ПО--формул более разнообразно, чем, например, представление дизъюнктов, используемых в методе резолюций в силу использования разнородных сущностей в структуре формулы: база, вопросы, консеквенты вопросов, два типа кванторов. То есть, требуются применение специальных методов доступа к данным неоднородным частям ПО--формулы, а также разработка специальных структур данных представления ПО--формул. В данном случае решение проблемы направлено на повышение эффективности согласно критериям 1--3.

\item Несмотря на то, что изначально представление формулы языка предикатов в языке ПО--формул более компактно чем КНФ, применение правила вывода в процессе построения ЛВ при наличии дизъюнктивного ветвления, в общем случае, приводит к б\'{о}льшему усложнению структуры формулы, чем при применении правила резолюции. Таким образом, через некоторое количество шагов вывода размер ПО--формулы может оказаться в разы больше чем размер соответствующей КНФ. Другим фактором, присущим для всех методов и систем АДТ является неограниченная планка сложности решаемых задач. Некоторые формализации изначально являются весьма крупными. Отсюда вытекает потребность в обеспечении экономного использования памяти, а также функционирования системы в режиме полного заполнения доступной памяти. В данном случае решение проблемы направлено на повышение эффективности согласно критерию 3.

\item Для решения прикладных задач необходимо обеспечить настраиваемость системы АДТ для учета особенностей конкретной задачи.
\end{enumerate}


%=================================================================================
%=================================================================================
\section{Постановка задачи исследования}
Поскольку в данной работе рассматривается первопорядковый язык ПО--формул, некоторые из структур данных и алгоритмов имеют сходства с уже существующими системам АДТ первого порядка. Это касается структуры термов и представления подстановок. Кроме того, существуют стандартные методы решения конкретных технических задач, не зависящие от реализуемого формализма, например, параллельные схемы алгоритмов, экономия потребляемой памяти, индексирование данных. В связи с этим необходимо реализовать адаптацию существующих методик, используемых в современных эффективных системах АДТ. Адаптация предполагает, во--первых, учет особенностей ПО--формализма, как совместимых с данными алгоритмами, так и проблемных; во--вторых, решение задачи обеспечения совместимости адаптируемых алгоритмов, поскольку некоторые из них конфликтуют друг с другом при прямой независимой реализации. Кроме адаптации, для повышения эффективности поиска ЛВ требуется разработать ряд оригинальных специализированных подходов присущих ПО--формализму. Разработанные методы, подходы и алгоритмы должны быть направлены на повышение эффективности поиска ЛВ и не должны нарушать положительных особенностей ПО--формул.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "dis"
%%% End:
